// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  apply: (where?: ApplyWhereInput) => Promise<boolean>;
  match: (where?: MatchWhereInput) => Promise<boolean>;
  notifier: (where?: NotifierWhereInput) => Promise<boolean>;
  player: (where?: PlayerWhereInput) => Promise<boolean>;
  stadium: (where?: StadiumWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  apply: (where: ApplyWhereUniqueInput) => ApplyNullablePromise;
  applies: (args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Apply>;
  appliesConnection: (args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplyConnectionPromise;
  match: (where: MatchWhereUniqueInput) => MatchNullablePromise;
  matches: (args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Match>;
  matchesConnection: (args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MatchConnectionPromise;
  notifier: (where: NotifierWhereUniqueInput) => NotifierNullablePromise;
  notifiers: (args?: {
    where?: NotifierWhereInput;
    orderBy?: NotifierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notifier>;
  notifiersConnection: (args?: {
    where?: NotifierWhereInput;
    orderBy?: NotifierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotifierConnectionPromise;
  player: (where: PlayerWhereUniqueInput) => PlayerNullablePromise;
  players: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Player>;
  playersConnection: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlayerConnectionPromise;
  stadium: (where: StadiumWhereUniqueInput) => StadiumNullablePromise;
  stadiums: (args?: {
    where?: StadiumWhereInput;
    orderBy?: StadiumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Stadium>;
  stadiumsConnection: (args?: {
    where?: StadiumWhereInput;
    orderBy?: StadiumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StadiumConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamNullablePromise;
  teams: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Team>;
  teamsConnection: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeamConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApply: (data: ApplyCreateInput) => ApplyPromise;
  updateApply: (args: {
    data: ApplyUpdateInput;
    where: ApplyWhereUniqueInput;
  }) => ApplyPromise;
  upsertApply: (args: {
    where: ApplyWhereUniqueInput;
    create: ApplyCreateInput;
    update: ApplyUpdateInput;
  }) => ApplyPromise;
  deleteApply: (where: ApplyWhereUniqueInput) => ApplyPromise;
  deleteManyApplies: (where?: ApplyWhereInput) => BatchPayloadPromise;
  createMatch: (data: MatchCreateInput) => MatchPromise;
  updateMatch: (args: {
    data: MatchUpdateInput;
    where: MatchWhereUniqueInput;
  }) => MatchPromise;
  updateManyMatches: (args: {
    data: MatchUpdateManyMutationInput;
    where?: MatchWhereInput;
  }) => BatchPayloadPromise;
  upsertMatch: (args: {
    where: MatchWhereUniqueInput;
    create: MatchCreateInput;
    update: MatchUpdateInput;
  }) => MatchPromise;
  deleteMatch: (where: MatchWhereUniqueInput) => MatchPromise;
  deleteManyMatches: (where?: MatchWhereInput) => BatchPayloadPromise;
  createNotifier: (data: NotifierCreateInput) => NotifierPromise;
  updateNotifier: (args: {
    data: NotifierUpdateInput;
    where: NotifierWhereUniqueInput;
  }) => NotifierPromise;
  updateManyNotifiers: (args: {
    data: NotifierUpdateManyMutationInput;
    where?: NotifierWhereInput;
  }) => BatchPayloadPromise;
  upsertNotifier: (args: {
    where: NotifierWhereUniqueInput;
    create: NotifierCreateInput;
    update: NotifierUpdateInput;
  }) => NotifierPromise;
  deleteNotifier: (where: NotifierWhereUniqueInput) => NotifierPromise;
  deleteManyNotifiers: (where?: NotifierWhereInput) => BatchPayloadPromise;
  createPlayer: (data: PlayerCreateInput) => PlayerPromise;
  updatePlayer: (args: {
    data: PlayerUpdateInput;
    where: PlayerWhereUniqueInput;
  }) => PlayerPromise;
  updateManyPlayers: (args: {
    data: PlayerUpdateManyMutationInput;
    where?: PlayerWhereInput;
  }) => BatchPayloadPromise;
  upsertPlayer: (args: {
    where: PlayerWhereUniqueInput;
    create: PlayerCreateInput;
    update: PlayerUpdateInput;
  }) => PlayerPromise;
  deletePlayer: (where: PlayerWhereUniqueInput) => PlayerPromise;
  deleteManyPlayers: (where?: PlayerWhereInput) => BatchPayloadPromise;
  createStadium: (data: StadiumCreateInput) => StadiumPromise;
  updateStadium: (args: {
    data: StadiumUpdateInput;
    where: StadiumWhereUniqueInput;
  }) => StadiumPromise;
  updateManyStadiums: (args: {
    data: StadiumUpdateManyMutationInput;
    where?: StadiumWhereInput;
  }) => BatchPayloadPromise;
  upsertStadium: (args: {
    where: StadiumWhereUniqueInput;
    create: StadiumCreateInput;
    update: StadiumUpdateInput;
  }) => StadiumPromise;
  deleteStadium: (where: StadiumWhereUniqueInput) => StadiumPromise;
  deleteManyStadiums: (where?: StadiumWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (args: {
    data: TeamUpdateInput;
    where: TeamWhereUniqueInput;
  }) => TeamPromise;
  updateManyTeams: (args: {
    data: TeamUpdateManyMutationInput;
    where?: TeamWhereInput;
  }) => BatchPayloadPromise;
  upsertTeam: (args: {
    where: TeamWhereUniqueInput;
    create: TeamCreateInput;
    update: TeamUpdateInput;
  }) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  apply: (
    where?: ApplySubscriptionWhereInput
  ) => ApplySubscriptionPayloadSubscription;
  match: (
    where?: MatchSubscriptionWhereInput
  ) => MatchSubscriptionPayloadSubscription;
  notifier: (
    where?: NotifierSubscriptionWhereInput
  ) => NotifierSubscriptionPayloadSubscription;
  player: (
    where?: PlayerSubscriptionWhereInput
  ) => PlayerSubscriptionPayloadSubscription;
  stadium: (
    where?: StadiumSubscriptionWhereInput
  ) => StadiumSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Area =
  | "CNO"
  | "CGS"
  | "YSN"
  | "SDG"
  | "KJI"
  | "TDM"
  | "CNG"
  | "SBK"
  | "KBK"
  | "TBG"
  | "NWN"
  | "UPG"
  | "SDM"
  | "MPO"
  | "YGC"
  | "KSS"
  | "KRO"
  | "KCN"
  | "YDP"
  | "TJK"
  | "KNK"
  | "SCO"
  | "KNM"
  | "SPA"
  | "KDG";

export type Auth = "KAKAO" | "NAVER";

export type Status = "OPEN" | "CLOSED";

export type Result = "HOST" | "GUEST" | "DRAW";

export type NotifierOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "date_ASC"
  | "date_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC";

export type MatchOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "status_ASC"
  | "status_DESC"
  | "stadium_ASC"
  | "stadium_DESC"
  | "address_ASC"
  | "address_DESC"
  | "area_ASC"
  | "area_DESC"
  | "date_ASC"
  | "date_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "description_ASC"
  | "description_DESC"
  | "result_ASC"
  | "result_DESC";

export type ApplyOrderByInput = "seq_ASC" | "seq_DESC";

export type TeamOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "name_ASC"
  | "name_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "homeArea_ASC"
  | "homeArea_DESC"
  | "introduction_ASC"
  | "introduction_DESC"
  | "win_ASC"
  | "win_DESC"
  | "draw_ASC"
  | "draw_DESC"
  | "lose_ASC"
  | "lose_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "teamUniqueId_ASC"
  | "teamUniqueId_DESC";

export type PlayerOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "playerId_ASC"
  | "playerId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "email_ASC"
  | "email_DESC"
  | "authProvider_ASC"
  | "authProvider_DESC";

export type StadiumOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ApplyWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export interface NotifierWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  player?: Maybe<PlayerWhereInput>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  AND?: Maybe<NotifierWhereInput[] | NotifierWhereInput>;
  OR?: Maybe<NotifierWhereInput[] | NotifierWhereInput>;
  NOT?: Maybe<NotifierWhereInput[] | NotifierWhereInput>;
}

export interface PlayerWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  playerId?: Maybe<String>;
  playerId_not?: Maybe<String>;
  playerId_in?: Maybe<String[] | String>;
  playerId_not_in?: Maybe<String[] | String>;
  playerId_lt?: Maybe<String>;
  playerId_lte?: Maybe<String>;
  playerId_gt?: Maybe<String>;
  playerId_gte?: Maybe<String>;
  playerId_contains?: Maybe<String>;
  playerId_not_contains?: Maybe<String>;
  playerId_starts_with?: Maybe<String>;
  playerId_not_starts_with?: Maybe<String>;
  playerId_ends_with?: Maybe<String>;
  playerId_not_ends_with?: Maybe<String>;
  team?: Maybe<TeamWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  authProvider?: Maybe<Auth>;
  authProvider_not?: Maybe<Auth>;
  authProvider_in?: Maybe<Auth[] | Auth>;
  authProvider_not_in?: Maybe<Auth[] | Auth>;
  notiList_every?: Maybe<NotifierWhereInput>;
  notiList_some?: Maybe<NotifierWhereInput>;
  notiList_none?: Maybe<NotifierWhereInput>;
  uploadMatchList_every?: Maybe<MatchWhereInput>;
  uploadMatchList_some?: Maybe<MatchWhereInput>;
  uploadMatchList_none?: Maybe<MatchWhereInput>;
  teamCreate_every?: Maybe<TeamWhereInput>;
  teamCreate_some?: Maybe<TeamWhereInput>;
  teamCreate_none?: Maybe<TeamWhereInput>;
  applyingList_every?: Maybe<ApplyWhereInput>;
  applyingList_some?: Maybe<ApplyWhereInput>;
  applyingList_none?: Maybe<ApplyWhereInput>;
  AND?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
  OR?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
  NOT?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
}

export interface TeamWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  homeArea?: Maybe<Area>;
  homeArea_not?: Maybe<Area>;
  homeArea_in?: Maybe<Area[] | Area>;
  homeArea_not_in?: Maybe<Area[] | Area>;
  introduction?: Maybe<String>;
  introduction_not?: Maybe<String>;
  introduction_in?: Maybe<String[] | String>;
  introduction_not_in?: Maybe<String[] | String>;
  introduction_lt?: Maybe<String>;
  introduction_lte?: Maybe<String>;
  introduction_gt?: Maybe<String>;
  introduction_gte?: Maybe<String>;
  introduction_contains?: Maybe<String>;
  introduction_not_contains?: Maybe<String>;
  introduction_starts_with?: Maybe<String>;
  introduction_not_starts_with?: Maybe<String>;
  introduction_ends_with?: Maybe<String>;
  introduction_not_ends_with?: Maybe<String>;
  win?: Maybe<Int>;
  win_not?: Maybe<Int>;
  win_in?: Maybe<Int[] | Int>;
  win_not_in?: Maybe<Int[] | Int>;
  win_lt?: Maybe<Int>;
  win_lte?: Maybe<Int>;
  win_gt?: Maybe<Int>;
  win_gte?: Maybe<Int>;
  draw?: Maybe<Int>;
  draw_not?: Maybe<Int>;
  draw_in?: Maybe<Int[] | Int>;
  draw_not_in?: Maybe<Int[] | Int>;
  draw_lt?: Maybe<Int>;
  draw_lte?: Maybe<Int>;
  draw_gt?: Maybe<Int>;
  draw_gte?: Maybe<Int>;
  lose?: Maybe<Int>;
  lose_not?: Maybe<Int>;
  lose_in?: Maybe<Int[] | Int>;
  lose_not_in?: Maybe<Int[] | Int>;
  lose_lt?: Maybe<Int>;
  lose_lte?: Maybe<Int>;
  lose_gt?: Maybe<Int>;
  lose_gte?: Maybe<Int>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
  teamUniqueId_not?: Maybe<String>;
  teamUniqueId_in?: Maybe<String[] | String>;
  teamUniqueId_not_in?: Maybe<String[] | String>;
  teamUniqueId_lt?: Maybe<String>;
  teamUniqueId_lte?: Maybe<String>;
  teamUniqueId_gt?: Maybe<String>;
  teamUniqueId_gte?: Maybe<String>;
  teamUniqueId_contains?: Maybe<String>;
  teamUniqueId_not_contains?: Maybe<String>;
  teamUniqueId_starts_with?: Maybe<String>;
  teamUniqueId_not_starts_with?: Maybe<String>;
  teamUniqueId_ends_with?: Maybe<String>;
  teamUniqueId_not_ends_with?: Maybe<String>;
  owner?: Maybe<PlayerWhereInput>;
  members_every?: Maybe<PlayerWhereInput>;
  members_some?: Maybe<PlayerWhereInput>;
  members_none?: Maybe<PlayerWhereInput>;
  uploadMatchList_every?: Maybe<MatchWhereInput>;
  uploadMatchList_some?: Maybe<MatchWhereInput>;
  uploadMatchList_none?: Maybe<MatchWhereInput>;
  matchingDoneList_every?: Maybe<MatchWhereInput>;
  matchingDoneList_some?: Maybe<MatchWhereInput>;
  matchingDoneList_none?: Maybe<MatchWhereInput>;
  onApplyingList_every?: Maybe<ApplyWhereInput>;
  onApplyingList_some?: Maybe<ApplyWhereInput>;
  onApplyingList_none?: Maybe<ApplyWhereInput>;
  AND?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  OR?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  NOT?: Maybe<TeamWhereInput[] | TeamWhereInput>;
}

export interface MatchWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  author?: Maybe<PlayerWhereInput>;
  host?: Maybe<TeamWhereInput>;
  guest?: Maybe<TeamWhereInput>;
  status?: Maybe<Status>;
  status_not?: Maybe<Status>;
  status_in?: Maybe<Status[] | Status>;
  status_not_in?: Maybe<Status[] | Status>;
  stadium?: Maybe<String>;
  stadium_not?: Maybe<String>;
  stadium_in?: Maybe<String[] | String>;
  stadium_not_in?: Maybe<String[] | String>;
  stadium_lt?: Maybe<String>;
  stadium_lte?: Maybe<String>;
  stadium_gt?: Maybe<String>;
  stadium_gte?: Maybe<String>;
  stadium_contains?: Maybe<String>;
  stadium_not_contains?: Maybe<String>;
  stadium_starts_with?: Maybe<String>;
  stadium_not_starts_with?: Maybe<String>;
  stadium_ends_with?: Maybe<String>;
  stadium_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  area?: Maybe<Area>;
  area_not?: Maybe<Area>;
  area_in?: Maybe<Area[] | Area>;
  area_not_in?: Maybe<Area[] | Area>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  result?: Maybe<Result>;
  result_not?: Maybe<Result>;
  result_in?: Maybe<Result[] | Result>;
  result_not_in?: Maybe<Result[] | Result>;
  appliedLists_every?: Maybe<ApplyWhereInput>;
  appliedLists_some?: Maybe<ApplyWhereInput>;
  appliedLists_none?: Maybe<ApplyWhereInput>;
  AND?: Maybe<MatchWhereInput[] | MatchWhereInput>;
  OR?: Maybe<MatchWhereInput[] | MatchWhereInput>;
  NOT?: Maybe<MatchWhereInput[] | MatchWhereInput>;
}

export interface ApplyWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  team?: Maybe<TeamWhereInput>;
  player?: Maybe<PlayerWhereInput>;
  match?: Maybe<MatchWhereInput>;
  AND?: Maybe<ApplyWhereInput[] | ApplyWhereInput>;
  OR?: Maybe<ApplyWhereInput[] | ApplyWhereInput>;
  NOT?: Maybe<ApplyWhereInput[] | ApplyWhereInput>;
}

export type MatchWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export type NotifierWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export type PlayerWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
  playerId?: Maybe<String>;
}>;

export type StadiumWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export interface StadiumWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  AND?: Maybe<StadiumWhereInput[] | StadiumWhereInput>;
  OR?: Maybe<StadiumWhereInput[] | StadiumWhereInput>;
  NOT?: Maybe<StadiumWhereInput[] | StadiumWhereInput>;
}

export type TeamWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
}>;

export interface ApplyCreateInput {
  seq?: Maybe<Int>;
  team?: Maybe<TeamCreateOneWithoutOnApplyingListInput>;
  player?: Maybe<PlayerCreateOneWithoutApplyingListInput>;
  match?: Maybe<MatchCreateOneWithoutAppliedListsInput>;
}

export interface TeamCreateOneWithoutOnApplyingListInput {
  create?: Maybe<TeamCreateWithoutOnApplyingListInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamCreateWithoutOnApplyingListInput {
  seq?: Maybe<Int>;
  name: String;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId: String;
  owner?: Maybe<PlayerCreateOneWithoutTeamCreateInput>;
  members?: Maybe<PlayerCreateManyWithoutTeamInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutHostInput>;
  matchingDoneList?: Maybe<MatchCreateManyWithoutGuestInput>;
}

export interface PlayerCreateOneWithoutTeamCreateInput {
  create?: Maybe<PlayerCreateWithoutTeamCreateInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerCreateWithoutTeamCreateInput {
  seq?: Maybe<Int>;
  playerId: String;
  team?: Maybe<TeamCreateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider: Auth;
  notiList?: Maybe<NotifierCreateManyWithoutPlayerInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutAuthorInput>;
  applyingList?: Maybe<ApplyCreateManyWithoutPlayerInput>;
}

export interface TeamCreateOneWithoutMembersInput {
  create?: Maybe<TeamCreateWithoutMembersInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamCreateWithoutMembersInput {
  seq?: Maybe<Int>;
  name: String;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId: String;
  owner?: Maybe<PlayerCreateOneWithoutTeamCreateInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutHostInput>;
  matchingDoneList?: Maybe<MatchCreateManyWithoutGuestInput>;
  onApplyingList?: Maybe<ApplyCreateManyWithoutTeamInput>;
}

export interface MatchCreateManyWithoutHostInput {
  create?: Maybe<MatchCreateWithoutHostInput[] | MatchCreateWithoutHostInput>;
  connect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
}

export interface MatchCreateWithoutHostInput {
  seq?: Maybe<Int>;
  author: PlayerCreateOneWithoutUploadMatchListInput;
  guest?: Maybe<TeamCreateOneWithoutMatchingDoneListInput>;
  status: Status;
  stadium: String;
  address?: Maybe<String>;
  area: Area;
  date: String;
  startTime: String;
  endTime: String;
  description?: Maybe<String>;
  result?: Maybe<Result>;
  appliedLists?: Maybe<ApplyCreateManyWithoutMatchInput>;
}

export interface PlayerCreateOneWithoutUploadMatchListInput {
  create?: Maybe<PlayerCreateWithoutUploadMatchListInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerCreateWithoutUploadMatchListInput {
  seq?: Maybe<Int>;
  playerId: String;
  team?: Maybe<TeamCreateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider: Auth;
  notiList?: Maybe<NotifierCreateManyWithoutPlayerInput>;
  teamCreate?: Maybe<TeamCreateManyWithoutOwnerInput>;
  applyingList?: Maybe<ApplyCreateManyWithoutPlayerInput>;
}

export interface NotifierCreateManyWithoutPlayerInput {
  create?: Maybe<
    NotifierCreateWithoutPlayerInput[] | NotifierCreateWithoutPlayerInput
  >;
  connect?: Maybe<NotifierWhereUniqueInput[] | NotifierWhereUniqueInput>;
}

export interface NotifierCreateWithoutPlayerInput {
  seq?: Maybe<Int>;
  area?: Maybe<NotifierCreateareaInput>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface NotifierCreateareaInput {
  set?: Maybe<Area[] | Area>;
}

export interface TeamCreateManyWithoutOwnerInput {
  create?: Maybe<TeamCreateWithoutOwnerInput[] | TeamCreateWithoutOwnerInput>;
  connect?: Maybe<TeamWhereUniqueInput[] | TeamWhereUniqueInput>;
}

export interface TeamCreateWithoutOwnerInput {
  seq?: Maybe<Int>;
  name: String;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId: String;
  members?: Maybe<PlayerCreateManyWithoutTeamInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutHostInput>;
  matchingDoneList?: Maybe<MatchCreateManyWithoutGuestInput>;
  onApplyingList?: Maybe<ApplyCreateManyWithoutTeamInput>;
}

export interface PlayerCreateManyWithoutTeamInput {
  create?: Maybe<PlayerCreateWithoutTeamInput[] | PlayerCreateWithoutTeamInput>;
  connect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
}

export interface PlayerCreateWithoutTeamInput {
  seq?: Maybe<Int>;
  playerId: String;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider: Auth;
  notiList?: Maybe<NotifierCreateManyWithoutPlayerInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutAuthorInput>;
  teamCreate?: Maybe<TeamCreateManyWithoutOwnerInput>;
  applyingList?: Maybe<ApplyCreateManyWithoutPlayerInput>;
}

export interface MatchCreateManyWithoutAuthorInput {
  create?: Maybe<
    MatchCreateWithoutAuthorInput[] | MatchCreateWithoutAuthorInput
  >;
  connect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
}

export interface MatchCreateWithoutAuthorInput {
  seq?: Maybe<Int>;
  host: TeamCreateOneWithoutUploadMatchListInput;
  guest?: Maybe<TeamCreateOneWithoutMatchingDoneListInput>;
  status: Status;
  stadium: String;
  address?: Maybe<String>;
  area: Area;
  date: String;
  startTime: String;
  endTime: String;
  description?: Maybe<String>;
  result?: Maybe<Result>;
  appliedLists?: Maybe<ApplyCreateManyWithoutMatchInput>;
}

export interface TeamCreateOneWithoutUploadMatchListInput {
  create?: Maybe<TeamCreateWithoutUploadMatchListInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamCreateWithoutUploadMatchListInput {
  seq?: Maybe<Int>;
  name: String;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId: String;
  owner?: Maybe<PlayerCreateOneWithoutTeamCreateInput>;
  members?: Maybe<PlayerCreateManyWithoutTeamInput>;
  matchingDoneList?: Maybe<MatchCreateManyWithoutGuestInput>;
  onApplyingList?: Maybe<ApplyCreateManyWithoutTeamInput>;
}

export interface MatchCreateManyWithoutGuestInput {
  create?: Maybe<MatchCreateWithoutGuestInput[] | MatchCreateWithoutGuestInput>;
  connect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
}

export interface MatchCreateWithoutGuestInput {
  seq?: Maybe<Int>;
  author: PlayerCreateOneWithoutUploadMatchListInput;
  host: TeamCreateOneWithoutUploadMatchListInput;
  status: Status;
  stadium: String;
  address?: Maybe<String>;
  area: Area;
  date: String;
  startTime: String;
  endTime: String;
  description?: Maybe<String>;
  result?: Maybe<Result>;
  appliedLists?: Maybe<ApplyCreateManyWithoutMatchInput>;
}

export interface ApplyCreateManyWithoutMatchInput {
  create?: Maybe<ApplyCreateWithoutMatchInput[] | ApplyCreateWithoutMatchInput>;
  connect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
}

export interface ApplyCreateWithoutMatchInput {
  seq?: Maybe<Int>;
  team?: Maybe<TeamCreateOneWithoutOnApplyingListInput>;
  player?: Maybe<PlayerCreateOneWithoutApplyingListInput>;
}

export interface PlayerCreateOneWithoutApplyingListInput {
  create?: Maybe<PlayerCreateWithoutApplyingListInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerCreateWithoutApplyingListInput {
  seq?: Maybe<Int>;
  playerId: String;
  team?: Maybe<TeamCreateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider: Auth;
  notiList?: Maybe<NotifierCreateManyWithoutPlayerInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutAuthorInput>;
  teamCreate?: Maybe<TeamCreateManyWithoutOwnerInput>;
}

export interface ApplyCreateManyWithoutTeamInput {
  create?: Maybe<ApplyCreateWithoutTeamInput[] | ApplyCreateWithoutTeamInput>;
  connect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
}

export interface ApplyCreateWithoutTeamInput {
  seq?: Maybe<Int>;
  player?: Maybe<PlayerCreateOneWithoutApplyingListInput>;
  match?: Maybe<MatchCreateOneWithoutAppliedListsInput>;
}

export interface MatchCreateOneWithoutAppliedListsInput {
  create?: Maybe<MatchCreateWithoutAppliedListsInput>;
  connect?: Maybe<MatchWhereUniqueInput>;
}

export interface MatchCreateWithoutAppliedListsInput {
  seq?: Maybe<Int>;
  author: PlayerCreateOneWithoutUploadMatchListInput;
  host: TeamCreateOneWithoutUploadMatchListInput;
  guest?: Maybe<TeamCreateOneWithoutMatchingDoneListInput>;
  status: Status;
  stadium: String;
  address?: Maybe<String>;
  area: Area;
  date: String;
  startTime: String;
  endTime: String;
  description?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface TeamCreateOneWithoutMatchingDoneListInput {
  create?: Maybe<TeamCreateWithoutMatchingDoneListInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamCreateWithoutMatchingDoneListInput {
  seq?: Maybe<Int>;
  name: String;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId: String;
  owner?: Maybe<PlayerCreateOneWithoutTeamCreateInput>;
  members?: Maybe<PlayerCreateManyWithoutTeamInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutHostInput>;
  onApplyingList?: Maybe<ApplyCreateManyWithoutTeamInput>;
}

export interface ApplyCreateManyWithoutPlayerInput {
  create?: Maybe<
    ApplyCreateWithoutPlayerInput[] | ApplyCreateWithoutPlayerInput
  >;
  connect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
}

export interface ApplyCreateWithoutPlayerInput {
  seq?: Maybe<Int>;
  team?: Maybe<TeamCreateOneWithoutOnApplyingListInput>;
  match?: Maybe<MatchCreateOneWithoutAppliedListsInput>;
}

export interface ApplyUpdateInput {
  team?: Maybe<TeamUpdateOneWithoutOnApplyingListInput>;
  player?: Maybe<PlayerUpdateOneWithoutApplyingListInput>;
  match?: Maybe<MatchUpdateOneWithoutAppliedListsInput>;
}

export interface TeamUpdateOneWithoutOnApplyingListInput {
  create?: Maybe<TeamCreateWithoutOnApplyingListInput>;
  update?: Maybe<TeamUpdateWithoutOnApplyingListDataInput>;
  upsert?: Maybe<TeamUpsertWithoutOnApplyingListInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamUpdateWithoutOnApplyingListDataInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
  owner?: Maybe<PlayerUpdateOneWithoutTeamCreateInput>;
  members?: Maybe<PlayerUpdateManyWithoutTeamInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutHostInput>;
  matchingDoneList?: Maybe<MatchUpdateManyWithoutGuestInput>;
}

export interface PlayerUpdateOneWithoutTeamCreateInput {
  create?: Maybe<PlayerCreateWithoutTeamCreateInput>;
  update?: Maybe<PlayerUpdateWithoutTeamCreateDataInput>;
  upsert?: Maybe<PlayerUpsertWithoutTeamCreateInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerUpdateWithoutTeamCreateDataInput {
  playerId?: Maybe<String>;
  team?: Maybe<TeamUpdateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider?: Maybe<Auth>;
  notiList?: Maybe<NotifierUpdateManyWithoutPlayerInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutAuthorInput>;
  applyingList?: Maybe<ApplyUpdateManyWithoutPlayerInput>;
}

export interface TeamUpdateOneWithoutMembersInput {
  create?: Maybe<TeamCreateWithoutMembersInput>;
  update?: Maybe<TeamUpdateWithoutMembersDataInput>;
  upsert?: Maybe<TeamUpsertWithoutMembersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
  owner?: Maybe<PlayerUpdateOneWithoutTeamCreateInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutHostInput>;
  matchingDoneList?: Maybe<MatchUpdateManyWithoutGuestInput>;
  onApplyingList?: Maybe<ApplyUpdateManyWithoutTeamInput>;
}

export interface MatchUpdateManyWithoutHostInput {
  create?: Maybe<MatchCreateWithoutHostInput[] | MatchCreateWithoutHostInput>;
  delete?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  connect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  set?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  disconnect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  update?: Maybe<
    | MatchUpdateWithWhereUniqueWithoutHostInput[]
    | MatchUpdateWithWhereUniqueWithoutHostInput
  >;
  upsert?: Maybe<
    | MatchUpsertWithWhereUniqueWithoutHostInput[]
    | MatchUpsertWithWhereUniqueWithoutHostInput
  >;
  deleteMany?: Maybe<MatchScalarWhereInput[] | MatchScalarWhereInput>;
  updateMany?: Maybe<
    MatchUpdateManyWithWhereNestedInput[] | MatchUpdateManyWithWhereNestedInput
  >;
}

export interface MatchUpdateWithWhereUniqueWithoutHostInput {
  where: MatchWhereUniqueInput;
  data: MatchUpdateWithoutHostDataInput;
}

export interface MatchUpdateWithoutHostDataInput {
  author?: Maybe<PlayerUpdateOneRequiredWithoutUploadMatchListInput>;
  guest?: Maybe<TeamUpdateOneWithoutMatchingDoneListInput>;
  status?: Maybe<Status>;
  stadium?: Maybe<String>;
  address?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
  appliedLists?: Maybe<ApplyUpdateManyWithoutMatchInput>;
}

export interface PlayerUpdateOneRequiredWithoutUploadMatchListInput {
  create?: Maybe<PlayerCreateWithoutUploadMatchListInput>;
  update?: Maybe<PlayerUpdateWithoutUploadMatchListDataInput>;
  upsert?: Maybe<PlayerUpsertWithoutUploadMatchListInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerUpdateWithoutUploadMatchListDataInput {
  playerId?: Maybe<String>;
  team?: Maybe<TeamUpdateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider?: Maybe<Auth>;
  notiList?: Maybe<NotifierUpdateManyWithoutPlayerInput>;
  teamCreate?: Maybe<TeamUpdateManyWithoutOwnerInput>;
  applyingList?: Maybe<ApplyUpdateManyWithoutPlayerInput>;
}

export interface NotifierUpdateManyWithoutPlayerInput {
  create?: Maybe<
    NotifierCreateWithoutPlayerInput[] | NotifierCreateWithoutPlayerInput
  >;
  delete?: Maybe<NotifierWhereUniqueInput[] | NotifierWhereUniqueInput>;
  connect?: Maybe<NotifierWhereUniqueInput[] | NotifierWhereUniqueInput>;
  set?: Maybe<NotifierWhereUniqueInput[] | NotifierWhereUniqueInput>;
  disconnect?: Maybe<NotifierWhereUniqueInput[] | NotifierWhereUniqueInput>;
  update?: Maybe<
    | NotifierUpdateWithWhereUniqueWithoutPlayerInput[]
    | NotifierUpdateWithWhereUniqueWithoutPlayerInput
  >;
  upsert?: Maybe<
    | NotifierUpsertWithWhereUniqueWithoutPlayerInput[]
    | NotifierUpsertWithWhereUniqueWithoutPlayerInput
  >;
  deleteMany?: Maybe<NotifierScalarWhereInput[] | NotifierScalarWhereInput>;
  updateMany?: Maybe<
    | NotifierUpdateManyWithWhereNestedInput[]
    | NotifierUpdateManyWithWhereNestedInput
  >;
}

export interface NotifierUpdateWithWhereUniqueWithoutPlayerInput {
  where: NotifierWhereUniqueInput;
  data: NotifierUpdateWithoutPlayerDataInput;
}

export interface NotifierUpdateWithoutPlayerDataInput {
  area?: Maybe<NotifierUpdateareaInput>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface NotifierUpdateareaInput {
  set?: Maybe<Area[] | Area>;
}

export interface NotifierUpsertWithWhereUniqueWithoutPlayerInput {
  where: NotifierWhereUniqueInput;
  update: NotifierUpdateWithoutPlayerDataInput;
  create: NotifierCreateWithoutPlayerInput;
}

export interface NotifierScalarWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  AND?: Maybe<NotifierScalarWhereInput[] | NotifierScalarWhereInput>;
  OR?: Maybe<NotifierScalarWhereInput[] | NotifierScalarWhereInput>;
  NOT?: Maybe<NotifierScalarWhereInput[] | NotifierScalarWhereInput>;
}

export interface NotifierUpdateManyWithWhereNestedInput {
  where: NotifierScalarWhereInput;
  data: NotifierUpdateManyDataInput;
}

export interface NotifierUpdateManyDataInput {
  area?: Maybe<NotifierUpdateareaInput>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface TeamUpdateManyWithoutOwnerInput {
  create?: Maybe<TeamCreateWithoutOwnerInput[] | TeamCreateWithoutOwnerInput>;
  delete?: Maybe<TeamWhereUniqueInput[] | TeamWhereUniqueInput>;
  connect?: Maybe<TeamWhereUniqueInput[] | TeamWhereUniqueInput>;
  set?: Maybe<TeamWhereUniqueInput[] | TeamWhereUniqueInput>;
  disconnect?: Maybe<TeamWhereUniqueInput[] | TeamWhereUniqueInput>;
  update?: Maybe<
    | TeamUpdateWithWhereUniqueWithoutOwnerInput[]
    | TeamUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | TeamUpsertWithWhereUniqueWithoutOwnerInput[]
    | TeamUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<TeamScalarWhereInput[] | TeamScalarWhereInput>;
  updateMany?: Maybe<
    TeamUpdateManyWithWhereNestedInput[] | TeamUpdateManyWithWhereNestedInput
  >;
}

export interface TeamUpdateWithWhereUniqueWithoutOwnerInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutOwnerDataInput;
}

export interface TeamUpdateWithoutOwnerDataInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
  members?: Maybe<PlayerUpdateManyWithoutTeamInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutHostInput>;
  matchingDoneList?: Maybe<MatchUpdateManyWithoutGuestInput>;
  onApplyingList?: Maybe<ApplyUpdateManyWithoutTeamInput>;
}

export interface PlayerUpdateManyWithoutTeamInput {
  create?: Maybe<PlayerCreateWithoutTeamInput[] | PlayerCreateWithoutTeamInput>;
  delete?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  connect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  set?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  disconnect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  update?: Maybe<
    | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    | PlayerUpdateWithWhereUniqueWithoutTeamInput
  >;
  upsert?: Maybe<
    | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    | PlayerUpsertWithWhereUniqueWithoutTeamInput
  >;
  deleteMany?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
  updateMany?: Maybe<
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput
  >;
}

export interface PlayerUpdateWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutTeamDataInput;
}

export interface PlayerUpdateWithoutTeamDataInput {
  playerId?: Maybe<String>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider?: Maybe<Auth>;
  notiList?: Maybe<NotifierUpdateManyWithoutPlayerInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutAuthorInput>;
  teamCreate?: Maybe<TeamUpdateManyWithoutOwnerInput>;
  applyingList?: Maybe<ApplyUpdateManyWithoutPlayerInput>;
}

export interface MatchUpdateManyWithoutAuthorInput {
  create?: Maybe<
    MatchCreateWithoutAuthorInput[] | MatchCreateWithoutAuthorInput
  >;
  delete?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  connect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  set?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  disconnect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  update?: Maybe<
    | MatchUpdateWithWhereUniqueWithoutAuthorInput[]
    | MatchUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | MatchUpsertWithWhereUniqueWithoutAuthorInput[]
    | MatchUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<MatchScalarWhereInput[] | MatchScalarWhereInput>;
  updateMany?: Maybe<
    MatchUpdateManyWithWhereNestedInput[] | MatchUpdateManyWithWhereNestedInput
  >;
}

export interface MatchUpdateWithWhereUniqueWithoutAuthorInput {
  where: MatchWhereUniqueInput;
  data: MatchUpdateWithoutAuthorDataInput;
}

export interface MatchUpdateWithoutAuthorDataInput {
  host?: Maybe<TeamUpdateOneRequiredWithoutUploadMatchListInput>;
  guest?: Maybe<TeamUpdateOneWithoutMatchingDoneListInput>;
  status?: Maybe<Status>;
  stadium?: Maybe<String>;
  address?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
  appliedLists?: Maybe<ApplyUpdateManyWithoutMatchInput>;
}

export interface TeamUpdateOneRequiredWithoutUploadMatchListInput {
  create?: Maybe<TeamCreateWithoutUploadMatchListInput>;
  update?: Maybe<TeamUpdateWithoutUploadMatchListDataInput>;
  upsert?: Maybe<TeamUpsertWithoutUploadMatchListInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamUpdateWithoutUploadMatchListDataInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
  owner?: Maybe<PlayerUpdateOneWithoutTeamCreateInput>;
  members?: Maybe<PlayerUpdateManyWithoutTeamInput>;
  matchingDoneList?: Maybe<MatchUpdateManyWithoutGuestInput>;
  onApplyingList?: Maybe<ApplyUpdateManyWithoutTeamInput>;
}

export interface MatchUpdateManyWithoutGuestInput {
  create?: Maybe<MatchCreateWithoutGuestInput[] | MatchCreateWithoutGuestInput>;
  delete?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  connect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  set?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  disconnect?: Maybe<MatchWhereUniqueInput[] | MatchWhereUniqueInput>;
  update?: Maybe<
    | MatchUpdateWithWhereUniqueWithoutGuestInput[]
    | MatchUpdateWithWhereUniqueWithoutGuestInput
  >;
  upsert?: Maybe<
    | MatchUpsertWithWhereUniqueWithoutGuestInput[]
    | MatchUpsertWithWhereUniqueWithoutGuestInput
  >;
  deleteMany?: Maybe<MatchScalarWhereInput[] | MatchScalarWhereInput>;
  updateMany?: Maybe<
    MatchUpdateManyWithWhereNestedInput[] | MatchUpdateManyWithWhereNestedInput
  >;
}

export interface MatchUpdateWithWhereUniqueWithoutGuestInput {
  where: MatchWhereUniqueInput;
  data: MatchUpdateWithoutGuestDataInput;
}

export interface MatchUpdateWithoutGuestDataInput {
  author?: Maybe<PlayerUpdateOneRequiredWithoutUploadMatchListInput>;
  host?: Maybe<TeamUpdateOneRequiredWithoutUploadMatchListInput>;
  status?: Maybe<Status>;
  stadium?: Maybe<String>;
  address?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
  appliedLists?: Maybe<ApplyUpdateManyWithoutMatchInput>;
}

export interface ApplyUpdateManyWithoutMatchInput {
  create?: Maybe<ApplyCreateWithoutMatchInput[] | ApplyCreateWithoutMatchInput>;
  delete?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  connect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  set?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  disconnect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  update?: Maybe<
    | ApplyUpdateWithWhereUniqueWithoutMatchInput[]
    | ApplyUpdateWithWhereUniqueWithoutMatchInput
  >;
  upsert?: Maybe<
    | ApplyUpsertWithWhereUniqueWithoutMatchInput[]
    | ApplyUpsertWithWhereUniqueWithoutMatchInput
  >;
  deleteMany?: Maybe<ApplyScalarWhereInput[] | ApplyScalarWhereInput>;
}

export interface ApplyUpdateWithWhereUniqueWithoutMatchInput {
  where: ApplyWhereUniqueInput;
  data: ApplyUpdateWithoutMatchDataInput;
}

export interface ApplyUpdateWithoutMatchDataInput {
  team?: Maybe<TeamUpdateOneWithoutOnApplyingListInput>;
  player?: Maybe<PlayerUpdateOneWithoutApplyingListInput>;
}

export interface PlayerUpdateOneWithoutApplyingListInput {
  create?: Maybe<PlayerCreateWithoutApplyingListInput>;
  update?: Maybe<PlayerUpdateWithoutApplyingListDataInput>;
  upsert?: Maybe<PlayerUpsertWithoutApplyingListInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerUpdateWithoutApplyingListDataInput {
  playerId?: Maybe<String>;
  team?: Maybe<TeamUpdateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider?: Maybe<Auth>;
  notiList?: Maybe<NotifierUpdateManyWithoutPlayerInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutAuthorInput>;
  teamCreate?: Maybe<TeamUpdateManyWithoutOwnerInput>;
}

export interface PlayerUpsertWithoutApplyingListInput {
  update: PlayerUpdateWithoutApplyingListDataInput;
  create: PlayerCreateWithoutApplyingListInput;
}

export interface ApplyUpsertWithWhereUniqueWithoutMatchInput {
  where: ApplyWhereUniqueInput;
  update: ApplyUpdateWithoutMatchDataInput;
  create: ApplyCreateWithoutMatchInput;
}

export interface ApplyScalarWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  AND?: Maybe<ApplyScalarWhereInput[] | ApplyScalarWhereInput>;
  OR?: Maybe<ApplyScalarWhereInput[] | ApplyScalarWhereInput>;
  NOT?: Maybe<ApplyScalarWhereInput[] | ApplyScalarWhereInput>;
}

export interface MatchUpsertWithWhereUniqueWithoutGuestInput {
  where: MatchWhereUniqueInput;
  update: MatchUpdateWithoutGuestDataInput;
  create: MatchCreateWithoutGuestInput;
}

export interface MatchScalarWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  status?: Maybe<Status>;
  status_not?: Maybe<Status>;
  status_in?: Maybe<Status[] | Status>;
  status_not_in?: Maybe<Status[] | Status>;
  stadium?: Maybe<String>;
  stadium_not?: Maybe<String>;
  stadium_in?: Maybe<String[] | String>;
  stadium_not_in?: Maybe<String[] | String>;
  stadium_lt?: Maybe<String>;
  stadium_lte?: Maybe<String>;
  stadium_gt?: Maybe<String>;
  stadium_gte?: Maybe<String>;
  stadium_contains?: Maybe<String>;
  stadium_not_contains?: Maybe<String>;
  stadium_starts_with?: Maybe<String>;
  stadium_not_starts_with?: Maybe<String>;
  stadium_ends_with?: Maybe<String>;
  stadium_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  area?: Maybe<Area>;
  area_not?: Maybe<Area>;
  area_in?: Maybe<Area[] | Area>;
  area_not_in?: Maybe<Area[] | Area>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  result?: Maybe<Result>;
  result_not?: Maybe<Result>;
  result_in?: Maybe<Result[] | Result>;
  result_not_in?: Maybe<Result[] | Result>;
  AND?: Maybe<MatchScalarWhereInput[] | MatchScalarWhereInput>;
  OR?: Maybe<MatchScalarWhereInput[] | MatchScalarWhereInput>;
  NOT?: Maybe<MatchScalarWhereInput[] | MatchScalarWhereInput>;
}

export interface MatchUpdateManyWithWhereNestedInput {
  where: MatchScalarWhereInput;
  data: MatchUpdateManyDataInput;
}

export interface MatchUpdateManyDataInput {
  status?: Maybe<Status>;
  stadium?: Maybe<String>;
  address?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface ApplyUpdateManyWithoutTeamInput {
  create?: Maybe<ApplyCreateWithoutTeamInput[] | ApplyCreateWithoutTeamInput>;
  delete?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  connect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  set?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  disconnect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  update?: Maybe<
    | ApplyUpdateWithWhereUniqueWithoutTeamInput[]
    | ApplyUpdateWithWhereUniqueWithoutTeamInput
  >;
  upsert?: Maybe<
    | ApplyUpsertWithWhereUniqueWithoutTeamInput[]
    | ApplyUpsertWithWhereUniqueWithoutTeamInput
  >;
  deleteMany?: Maybe<ApplyScalarWhereInput[] | ApplyScalarWhereInput>;
}

export interface ApplyUpdateWithWhereUniqueWithoutTeamInput {
  where: ApplyWhereUniqueInput;
  data: ApplyUpdateWithoutTeamDataInput;
}

export interface ApplyUpdateWithoutTeamDataInput {
  player?: Maybe<PlayerUpdateOneWithoutApplyingListInput>;
  match?: Maybe<MatchUpdateOneWithoutAppliedListsInput>;
}

export interface MatchUpdateOneWithoutAppliedListsInput {
  create?: Maybe<MatchCreateWithoutAppliedListsInput>;
  update?: Maybe<MatchUpdateWithoutAppliedListsDataInput>;
  upsert?: Maybe<MatchUpsertWithoutAppliedListsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MatchWhereUniqueInput>;
}

export interface MatchUpdateWithoutAppliedListsDataInput {
  author?: Maybe<PlayerUpdateOneRequiredWithoutUploadMatchListInput>;
  host?: Maybe<TeamUpdateOneRequiredWithoutUploadMatchListInput>;
  guest?: Maybe<TeamUpdateOneWithoutMatchingDoneListInput>;
  status?: Maybe<Status>;
  stadium?: Maybe<String>;
  address?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface TeamUpdateOneWithoutMatchingDoneListInput {
  create?: Maybe<TeamCreateWithoutMatchingDoneListInput>;
  update?: Maybe<TeamUpdateWithoutMatchingDoneListDataInput>;
  upsert?: Maybe<TeamUpsertWithoutMatchingDoneListInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamUpdateWithoutMatchingDoneListDataInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
  owner?: Maybe<PlayerUpdateOneWithoutTeamCreateInput>;
  members?: Maybe<PlayerUpdateManyWithoutTeamInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutHostInput>;
  onApplyingList?: Maybe<ApplyUpdateManyWithoutTeamInput>;
}

export interface TeamUpsertWithoutMatchingDoneListInput {
  update: TeamUpdateWithoutMatchingDoneListDataInput;
  create: TeamCreateWithoutMatchingDoneListInput;
}

export interface MatchUpsertWithoutAppliedListsInput {
  update: MatchUpdateWithoutAppliedListsDataInput;
  create: MatchCreateWithoutAppliedListsInput;
}

export interface ApplyUpsertWithWhereUniqueWithoutTeamInput {
  where: ApplyWhereUniqueInput;
  update: ApplyUpdateWithoutTeamDataInput;
  create: ApplyCreateWithoutTeamInput;
}

export interface TeamUpsertWithoutUploadMatchListInput {
  update: TeamUpdateWithoutUploadMatchListDataInput;
  create: TeamCreateWithoutUploadMatchListInput;
}

export interface MatchUpsertWithWhereUniqueWithoutAuthorInput {
  where: MatchWhereUniqueInput;
  update: MatchUpdateWithoutAuthorDataInput;
  create: MatchCreateWithoutAuthorInput;
}

export interface ApplyUpdateManyWithoutPlayerInput {
  create?: Maybe<
    ApplyCreateWithoutPlayerInput[] | ApplyCreateWithoutPlayerInput
  >;
  delete?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  connect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  set?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  disconnect?: Maybe<ApplyWhereUniqueInput[] | ApplyWhereUniqueInput>;
  update?: Maybe<
    | ApplyUpdateWithWhereUniqueWithoutPlayerInput[]
    | ApplyUpdateWithWhereUniqueWithoutPlayerInput
  >;
  upsert?: Maybe<
    | ApplyUpsertWithWhereUniqueWithoutPlayerInput[]
    | ApplyUpsertWithWhereUniqueWithoutPlayerInput
  >;
  deleteMany?: Maybe<ApplyScalarWhereInput[] | ApplyScalarWhereInput>;
}

export interface ApplyUpdateWithWhereUniqueWithoutPlayerInput {
  where: ApplyWhereUniqueInput;
  data: ApplyUpdateWithoutPlayerDataInput;
}

export interface ApplyUpdateWithoutPlayerDataInput {
  team?: Maybe<TeamUpdateOneWithoutOnApplyingListInput>;
  match?: Maybe<MatchUpdateOneWithoutAppliedListsInput>;
}

export interface ApplyUpsertWithWhereUniqueWithoutPlayerInput {
  where: ApplyWhereUniqueInput;
  update: ApplyUpdateWithoutPlayerDataInput;
  create: ApplyCreateWithoutPlayerInput;
}

export interface PlayerUpsertWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutTeamDataInput;
  create: PlayerCreateWithoutTeamInput;
}

export interface PlayerScalarWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  playerId?: Maybe<String>;
  playerId_not?: Maybe<String>;
  playerId_in?: Maybe<String[] | String>;
  playerId_not_in?: Maybe<String[] | String>;
  playerId_lt?: Maybe<String>;
  playerId_lte?: Maybe<String>;
  playerId_gt?: Maybe<String>;
  playerId_gte?: Maybe<String>;
  playerId_contains?: Maybe<String>;
  playerId_not_contains?: Maybe<String>;
  playerId_starts_with?: Maybe<String>;
  playerId_not_starts_with?: Maybe<String>;
  playerId_ends_with?: Maybe<String>;
  playerId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  authProvider?: Maybe<Auth>;
  authProvider_not?: Maybe<Auth>;
  authProvider_in?: Maybe<Auth[] | Auth>;
  authProvider_not_in?: Maybe<Auth[] | Auth>;
  AND?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
  OR?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
  NOT?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
}

export interface PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput;
  data: PlayerUpdateManyDataInput;
}

export interface PlayerUpdateManyDataInput {
  playerId?: Maybe<String>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider?: Maybe<Auth>;
}

export interface TeamUpsertWithWhereUniqueWithoutOwnerInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutOwnerDataInput;
  create: TeamCreateWithoutOwnerInput;
}

export interface TeamScalarWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  homeArea?: Maybe<Area>;
  homeArea_not?: Maybe<Area>;
  homeArea_in?: Maybe<Area[] | Area>;
  homeArea_not_in?: Maybe<Area[] | Area>;
  introduction?: Maybe<String>;
  introduction_not?: Maybe<String>;
  introduction_in?: Maybe<String[] | String>;
  introduction_not_in?: Maybe<String[] | String>;
  introduction_lt?: Maybe<String>;
  introduction_lte?: Maybe<String>;
  introduction_gt?: Maybe<String>;
  introduction_gte?: Maybe<String>;
  introduction_contains?: Maybe<String>;
  introduction_not_contains?: Maybe<String>;
  introduction_starts_with?: Maybe<String>;
  introduction_not_starts_with?: Maybe<String>;
  introduction_ends_with?: Maybe<String>;
  introduction_not_ends_with?: Maybe<String>;
  win?: Maybe<Int>;
  win_not?: Maybe<Int>;
  win_in?: Maybe<Int[] | Int>;
  win_not_in?: Maybe<Int[] | Int>;
  win_lt?: Maybe<Int>;
  win_lte?: Maybe<Int>;
  win_gt?: Maybe<Int>;
  win_gte?: Maybe<Int>;
  draw?: Maybe<Int>;
  draw_not?: Maybe<Int>;
  draw_in?: Maybe<Int[] | Int>;
  draw_not_in?: Maybe<Int[] | Int>;
  draw_lt?: Maybe<Int>;
  draw_lte?: Maybe<Int>;
  draw_gt?: Maybe<Int>;
  draw_gte?: Maybe<Int>;
  lose?: Maybe<Int>;
  lose_not?: Maybe<Int>;
  lose_in?: Maybe<Int[] | Int>;
  lose_not_in?: Maybe<Int[] | Int>;
  lose_lt?: Maybe<Int>;
  lose_lte?: Maybe<Int>;
  lose_gt?: Maybe<Int>;
  lose_gte?: Maybe<Int>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
  teamUniqueId_not?: Maybe<String>;
  teamUniqueId_in?: Maybe<String[] | String>;
  teamUniqueId_not_in?: Maybe<String[] | String>;
  teamUniqueId_lt?: Maybe<String>;
  teamUniqueId_lte?: Maybe<String>;
  teamUniqueId_gt?: Maybe<String>;
  teamUniqueId_gte?: Maybe<String>;
  teamUniqueId_contains?: Maybe<String>;
  teamUniqueId_not_contains?: Maybe<String>;
  teamUniqueId_starts_with?: Maybe<String>;
  teamUniqueId_not_starts_with?: Maybe<String>;
  teamUniqueId_ends_with?: Maybe<String>;
  teamUniqueId_not_ends_with?: Maybe<String>;
  AND?: Maybe<TeamScalarWhereInput[] | TeamScalarWhereInput>;
  OR?: Maybe<TeamScalarWhereInput[] | TeamScalarWhereInput>;
  NOT?: Maybe<TeamScalarWhereInput[] | TeamScalarWhereInput>;
}

export interface TeamUpdateManyWithWhereNestedInput {
  where: TeamScalarWhereInput;
  data: TeamUpdateManyDataInput;
}

export interface TeamUpdateManyDataInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
}

export interface PlayerUpsertWithoutUploadMatchListInput {
  update: PlayerUpdateWithoutUploadMatchListDataInput;
  create: PlayerCreateWithoutUploadMatchListInput;
}

export interface MatchUpsertWithWhereUniqueWithoutHostInput {
  where: MatchWhereUniqueInput;
  update: MatchUpdateWithoutHostDataInput;
  create: MatchCreateWithoutHostInput;
}

export interface TeamUpsertWithoutMembersInput {
  update: TeamUpdateWithoutMembersDataInput;
  create: TeamCreateWithoutMembersInput;
}

export interface PlayerUpsertWithoutTeamCreateInput {
  update: PlayerUpdateWithoutTeamCreateDataInput;
  create: PlayerCreateWithoutTeamCreateInput;
}

export interface TeamUpsertWithoutOnApplyingListInput {
  update: TeamUpdateWithoutOnApplyingListDataInput;
  create: TeamCreateWithoutOnApplyingListInput;
}

export interface MatchCreateInput {
  seq?: Maybe<Int>;
  author: PlayerCreateOneWithoutUploadMatchListInput;
  host: TeamCreateOneWithoutUploadMatchListInput;
  guest?: Maybe<TeamCreateOneWithoutMatchingDoneListInput>;
  status: Status;
  stadium: String;
  address?: Maybe<String>;
  area: Area;
  date: String;
  startTime: String;
  endTime: String;
  description?: Maybe<String>;
  result?: Maybe<Result>;
  appliedLists?: Maybe<ApplyCreateManyWithoutMatchInput>;
}

export interface MatchUpdateInput {
  author?: Maybe<PlayerUpdateOneRequiredWithoutUploadMatchListInput>;
  host?: Maybe<TeamUpdateOneRequiredWithoutUploadMatchListInput>;
  guest?: Maybe<TeamUpdateOneWithoutMatchingDoneListInput>;
  status?: Maybe<Status>;
  stadium?: Maybe<String>;
  address?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
  appliedLists?: Maybe<ApplyUpdateManyWithoutMatchInput>;
}

export interface MatchUpdateManyMutationInput {
  status?: Maybe<Status>;
  stadium?: Maybe<String>;
  address?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface NotifierCreateInput {
  seq?: Maybe<Int>;
  player: PlayerCreateOneWithoutNotiListInput;
  area?: Maybe<NotifierCreateareaInput>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface PlayerCreateOneWithoutNotiListInput {
  create?: Maybe<PlayerCreateWithoutNotiListInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerCreateWithoutNotiListInput {
  seq?: Maybe<Int>;
  playerId: String;
  team?: Maybe<TeamCreateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider: Auth;
  uploadMatchList?: Maybe<MatchCreateManyWithoutAuthorInput>;
  teamCreate?: Maybe<TeamCreateManyWithoutOwnerInput>;
  applyingList?: Maybe<ApplyCreateManyWithoutPlayerInput>;
}

export interface NotifierUpdateInput {
  player?: Maybe<PlayerUpdateOneRequiredWithoutNotiListInput>;
  area?: Maybe<NotifierUpdateareaInput>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface PlayerUpdateOneRequiredWithoutNotiListInput {
  create?: Maybe<PlayerCreateWithoutNotiListInput>;
  update?: Maybe<PlayerUpdateWithoutNotiListDataInput>;
  upsert?: Maybe<PlayerUpsertWithoutNotiListInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerUpdateWithoutNotiListDataInput {
  playerId?: Maybe<String>;
  team?: Maybe<TeamUpdateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider?: Maybe<Auth>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutAuthorInput>;
  teamCreate?: Maybe<TeamUpdateManyWithoutOwnerInput>;
  applyingList?: Maybe<ApplyUpdateManyWithoutPlayerInput>;
}

export interface PlayerUpsertWithoutNotiListInput {
  update: PlayerUpdateWithoutNotiListDataInput;
  create: PlayerCreateWithoutNotiListInput;
}

export interface NotifierUpdateManyMutationInput {
  area?: Maybe<NotifierUpdateareaInput>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface PlayerCreateInput {
  seq?: Maybe<Int>;
  playerId: String;
  team?: Maybe<TeamCreateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider: Auth;
  notiList?: Maybe<NotifierCreateManyWithoutPlayerInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutAuthorInput>;
  teamCreate?: Maybe<TeamCreateManyWithoutOwnerInput>;
  applyingList?: Maybe<ApplyCreateManyWithoutPlayerInput>;
}

export interface PlayerUpdateInput {
  playerId?: Maybe<String>;
  team?: Maybe<TeamUpdateOneWithoutMembersInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider?: Maybe<Auth>;
  notiList?: Maybe<NotifierUpdateManyWithoutPlayerInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutAuthorInput>;
  teamCreate?: Maybe<TeamUpdateManyWithoutOwnerInput>;
  applyingList?: Maybe<ApplyUpdateManyWithoutPlayerInput>;
}

export interface PlayerUpdateManyMutationInput {
  playerId?: Maybe<String>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  authProvider?: Maybe<Auth>;
}

export interface StadiumCreateInput {
  seq?: Maybe<Int>;
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface StadiumUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface StadiumUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface TeamCreateInput {
  seq?: Maybe<Int>;
  name: String;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId: String;
  owner?: Maybe<PlayerCreateOneWithoutTeamCreateInput>;
  members?: Maybe<PlayerCreateManyWithoutTeamInput>;
  uploadMatchList?: Maybe<MatchCreateManyWithoutHostInput>;
  matchingDoneList?: Maybe<MatchCreateManyWithoutGuestInput>;
  onApplyingList?: Maybe<ApplyCreateManyWithoutTeamInput>;
}

export interface TeamUpdateInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
  owner?: Maybe<PlayerUpdateOneWithoutTeamCreateInput>;
  members?: Maybe<PlayerUpdateManyWithoutTeamInput>;
  uploadMatchList?: Maybe<MatchUpdateManyWithoutHostInput>;
  matchingDoneList?: Maybe<MatchUpdateManyWithoutGuestInput>;
  onApplyingList?: Maybe<ApplyUpdateManyWithoutTeamInput>;
}

export interface TeamUpdateManyMutationInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  homeArea?: Maybe<Area>;
  introduction?: Maybe<String>;
  win?: Maybe<Int>;
  draw?: Maybe<Int>;
  lose?: Maybe<Int>;
  rating?: Maybe<Int>;
  teamUniqueId?: Maybe<String>;
}

export interface ApplySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplyWhereInput>;
  AND?: Maybe<ApplySubscriptionWhereInput[] | ApplySubscriptionWhereInput>;
  OR?: Maybe<ApplySubscriptionWhereInput[] | ApplySubscriptionWhereInput>;
  NOT?: Maybe<ApplySubscriptionWhereInput[] | ApplySubscriptionWhereInput>;
}

export interface MatchSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MatchWhereInput>;
  AND?: Maybe<MatchSubscriptionWhereInput[] | MatchSubscriptionWhereInput>;
  OR?: Maybe<MatchSubscriptionWhereInput[] | MatchSubscriptionWhereInput>;
  NOT?: Maybe<MatchSubscriptionWhereInput[] | MatchSubscriptionWhereInput>;
}

export interface NotifierSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NotifierWhereInput>;
  AND?: Maybe<
    NotifierSubscriptionWhereInput[] | NotifierSubscriptionWhereInput
  >;
  OR?: Maybe<NotifierSubscriptionWhereInput[] | NotifierSubscriptionWhereInput>;
  NOT?: Maybe<
    NotifierSubscriptionWhereInput[] | NotifierSubscriptionWhereInput
  >;
}

export interface PlayerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlayerWhereInput>;
  AND?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
  OR?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
  NOT?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
}

export interface StadiumSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StadiumWhereInput>;
  AND?: Maybe<StadiumSubscriptionWhereInput[] | StadiumSubscriptionWhereInput>;
  OR?: Maybe<StadiumSubscriptionWhereInput[] | StadiumSubscriptionWhereInput>;
  NOT?: Maybe<StadiumSubscriptionWhereInput[] | StadiumSubscriptionWhereInput>;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TeamWhereInput>;
  AND?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  OR?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  NOT?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Apply {
  seq: Int;
}

export interface ApplyPromise extends Promise<Apply>, Fragmentable {
  seq: () => Promise<Int>;
  team: <T = TeamPromise>() => T;
  player: <T = PlayerPromise>() => T;
  match: <T = MatchPromise>() => T;
}

export interface ApplySubscription
  extends Promise<AsyncIterator<Apply>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  team: <T = TeamSubscription>() => T;
  player: <T = PlayerSubscription>() => T;
  match: <T = MatchSubscription>() => T;
}

export interface ApplyNullablePromise
  extends Promise<Apply | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  team: <T = TeamPromise>() => T;
  player: <T = PlayerPromise>() => T;
  match: <T = MatchPromise>() => T;
}

export interface Team {
  seq: Int;
  name: String;
  logo?: String;
  homeArea?: Area;
  introduction?: String;
  win: Int;
  draw: Int;
  lose: Int;
  rating: Int;
  teamUniqueId: String;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  logo: () => Promise<String>;
  homeArea: () => Promise<Area>;
  introduction: () => Promise<String>;
  win: () => Promise<Int>;
  draw: () => Promise<Int>;
  lose: () => Promise<Int>;
  rating: () => Promise<Int>;
  teamUniqueId: () => Promise<String>;
  owner: <T = PlayerPromise>() => T;
  members: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uploadMatchList: <T = FragmentableArray<Match>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  matchingDoneList: <T = FragmentableArray<Match>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  onApplyingList: <T = FragmentableArray<Apply>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  homeArea: () => Promise<AsyncIterator<Area>>;
  introduction: () => Promise<AsyncIterator<String>>;
  win: () => Promise<AsyncIterator<Int>>;
  draw: () => Promise<AsyncIterator<Int>>;
  lose: () => Promise<AsyncIterator<Int>>;
  rating: () => Promise<AsyncIterator<Int>>;
  teamUniqueId: () => Promise<AsyncIterator<String>>;
  owner: <T = PlayerSubscription>() => T;
  members: <T = Promise<AsyncIterator<PlayerSubscription>>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uploadMatchList: <T = Promise<AsyncIterator<MatchSubscription>>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  matchingDoneList: <T = Promise<AsyncIterator<MatchSubscription>>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  onApplyingList: <T = Promise<AsyncIterator<ApplySubscription>>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TeamNullablePromise
  extends Promise<Team | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  logo: () => Promise<String>;
  homeArea: () => Promise<Area>;
  introduction: () => Promise<String>;
  win: () => Promise<Int>;
  draw: () => Promise<Int>;
  lose: () => Promise<Int>;
  rating: () => Promise<Int>;
  teamUniqueId: () => Promise<String>;
  owner: <T = PlayerPromise>() => T;
  members: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uploadMatchList: <T = FragmentableArray<Match>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  matchingDoneList: <T = FragmentableArray<Match>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  onApplyingList: <T = FragmentableArray<Apply>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Player {
  seq: Int;
  playerId: String;
  name?: String;
  phone?: String;
  email?: String;
  authProvider: Auth;
}

export interface PlayerPromise extends Promise<Player>, Fragmentable {
  seq: () => Promise<Int>;
  playerId: () => Promise<String>;
  team: <T = TeamPromise>() => T;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  authProvider: () => Promise<Auth>;
  notiList: <T = FragmentableArray<Notifier>>(args?: {
    where?: NotifierWhereInput;
    orderBy?: NotifierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uploadMatchList: <T = FragmentableArray<Match>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teamCreate: <T = FragmentableArray<Team>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applyingList: <T = FragmentableArray<Apply>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlayerSubscription
  extends Promise<AsyncIterator<Player>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  playerId: () => Promise<AsyncIterator<String>>;
  team: <T = TeamSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  authProvider: () => Promise<AsyncIterator<Auth>>;
  notiList: <T = Promise<AsyncIterator<NotifierSubscription>>>(args?: {
    where?: NotifierWhereInput;
    orderBy?: NotifierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uploadMatchList: <T = Promise<AsyncIterator<MatchSubscription>>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teamCreate: <T = Promise<AsyncIterator<TeamSubscription>>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applyingList: <T = Promise<AsyncIterator<ApplySubscription>>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlayerNullablePromise
  extends Promise<Player | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  playerId: () => Promise<String>;
  team: <T = TeamPromise>() => T;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  authProvider: () => Promise<Auth>;
  notiList: <T = FragmentableArray<Notifier>>(args?: {
    where?: NotifierWhereInput;
    orderBy?: NotifierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uploadMatchList: <T = FragmentableArray<Match>>(args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teamCreate: <T = FragmentableArray<Team>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applyingList: <T = FragmentableArray<Apply>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Notifier {
  seq: Int;
  area: Area[];
  date?: String;
  startTime?: String;
  endTime?: String;
}

export interface NotifierPromise extends Promise<Notifier>, Fragmentable {
  seq: () => Promise<Int>;
  player: <T = PlayerPromise>() => T;
  area: () => Promise<Area[]>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
}

export interface NotifierSubscription
  extends Promise<AsyncIterator<Notifier>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  player: <T = PlayerSubscription>() => T;
  area: () => Promise<AsyncIterator<Area[]>>;
  date: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
}

export interface NotifierNullablePromise
  extends Promise<Notifier | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  player: <T = PlayerPromise>() => T;
  area: () => Promise<Area[]>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
}

export interface Match {
  seq: Int;
  status: Status;
  stadium: String;
  address?: String;
  area: Area;
  date: String;
  startTime: String;
  endTime: String;
  description?: String;
  result?: Result;
}

export interface MatchPromise extends Promise<Match>, Fragmentable {
  seq: () => Promise<Int>;
  author: <T = PlayerPromise>() => T;
  host: <T = TeamPromise>() => T;
  guest: <T = TeamPromise>() => T;
  status: () => Promise<Status>;
  stadium: () => Promise<String>;
  address: () => Promise<String>;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  description: () => Promise<String>;
  result: () => Promise<Result>;
  appliedLists: <T = FragmentableArray<Apply>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MatchSubscription
  extends Promise<AsyncIterator<Match>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  author: <T = PlayerSubscription>() => T;
  host: <T = TeamSubscription>() => T;
  guest: <T = TeamSubscription>() => T;
  status: () => Promise<AsyncIterator<Status>>;
  stadium: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<Area>>;
  date: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<Result>>;
  appliedLists: <T = Promise<AsyncIterator<ApplySubscription>>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MatchNullablePromise
  extends Promise<Match | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  author: <T = PlayerPromise>() => T;
  host: <T = TeamPromise>() => T;
  guest: <T = TeamPromise>() => T;
  status: () => Promise<Status>;
  stadium: () => Promise<String>;
  address: () => Promise<String>;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  description: () => Promise<String>;
  result: () => Promise<Result>;
  appliedLists: <T = FragmentableArray<Apply>>(args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ApplyConnection {
  pageInfo: PageInfo;
  edges: ApplyEdge[];
}

export interface ApplyConnectionPromise
  extends Promise<ApplyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplyEdge>>() => T;
  aggregate: <T = AggregateApplyPromise>() => T;
}

export interface ApplyConnectionSubscription
  extends Promise<AsyncIterator<ApplyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplyEdge {
  node: Apply;
  cursor: String;
}

export interface ApplyEdgePromise extends Promise<ApplyEdge>, Fragmentable {
  node: <T = ApplyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplyEdgeSubscription
  extends Promise<AsyncIterator<ApplyEdge>>,
    Fragmentable {
  node: <T = ApplySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApply {
  count: Int;
}

export interface AggregateApplyPromise
  extends Promise<AggregateApply>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplySubscription
  extends Promise<AsyncIterator<AggregateApply>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MatchConnection {
  pageInfo: PageInfo;
  edges: MatchEdge[];
}

export interface MatchConnectionPromise
  extends Promise<MatchConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MatchEdge>>() => T;
  aggregate: <T = AggregateMatchPromise>() => T;
}

export interface MatchConnectionSubscription
  extends Promise<AsyncIterator<MatchConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MatchEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMatchSubscription>() => T;
}

export interface MatchEdge {
  node: Match;
  cursor: String;
}

export interface MatchEdgePromise extends Promise<MatchEdge>, Fragmentable {
  node: <T = MatchPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MatchEdgeSubscription
  extends Promise<AsyncIterator<MatchEdge>>,
    Fragmentable {
  node: <T = MatchSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMatch {
  count: Int;
}

export interface AggregateMatchPromise
  extends Promise<AggregateMatch>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMatchSubscription
  extends Promise<AsyncIterator<AggregateMatch>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotifierConnection {
  pageInfo: PageInfo;
  edges: NotifierEdge[];
}

export interface NotifierConnectionPromise
  extends Promise<NotifierConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotifierEdge>>() => T;
  aggregate: <T = AggregateNotifierPromise>() => T;
}

export interface NotifierConnectionSubscription
  extends Promise<AsyncIterator<NotifierConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotifierEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotifierSubscription>() => T;
}

export interface NotifierEdge {
  node: Notifier;
  cursor: String;
}

export interface NotifierEdgePromise
  extends Promise<NotifierEdge>,
    Fragmentable {
  node: <T = NotifierPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotifierEdgeSubscription
  extends Promise<AsyncIterator<NotifierEdge>>,
    Fragmentable {
  node: <T = NotifierSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotifier {
  count: Int;
}

export interface AggregateNotifierPromise
  extends Promise<AggregateNotifier>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotifierSubscription
  extends Promise<AsyncIterator<AggregateNotifier>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlayerConnection {
  pageInfo: PageInfo;
  edges: PlayerEdge[];
}

export interface PlayerConnectionPromise
  extends Promise<PlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlayerEdge>>() => T;
  aggregate: <T = AggregatePlayerPromise>() => T;
}

export interface PlayerConnectionSubscription
  extends Promise<AsyncIterator<PlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlayerSubscription>() => T;
}

export interface PlayerEdge {
  node: Player;
  cursor: String;
}

export interface PlayerEdgePromise extends Promise<PlayerEdge>, Fragmentable {
  node: <T = PlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlayerEdgeSubscription
  extends Promise<AsyncIterator<PlayerEdge>>,
    Fragmentable {
  node: <T = PlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlayer {
  count: Int;
}

export interface AggregatePlayerPromise
  extends Promise<AggregatePlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlayerSubscription
  extends Promise<AsyncIterator<AggregatePlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Stadium {
  seq: Int;
  name?: String;
  address?: String;
}

export interface StadiumPromise extends Promise<Stadium>, Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface StadiumSubscription
  extends Promise<AsyncIterator<Stadium>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface StadiumNullablePromise
  extends Promise<Stadium | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface StadiumConnection {
  pageInfo: PageInfo;
  edges: StadiumEdge[];
}

export interface StadiumConnectionPromise
  extends Promise<StadiumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StadiumEdge>>() => T;
  aggregate: <T = AggregateStadiumPromise>() => T;
}

export interface StadiumConnectionSubscription
  extends Promise<AsyncIterator<StadiumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StadiumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStadiumSubscription>() => T;
}

export interface StadiumEdge {
  node: Stadium;
  cursor: String;
}

export interface StadiumEdgePromise extends Promise<StadiumEdge>, Fragmentable {
  node: <T = StadiumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StadiumEdgeSubscription
  extends Promise<AsyncIterator<StadiumEdge>>,
    Fragmentable {
  node: <T = StadiumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStadium {
  count: Int;
}

export interface AggregateStadiumPromise
  extends Promise<AggregateStadium>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStadiumSubscription
  extends Promise<AsyncIterator<AggregateStadium>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ApplySubscriptionPayload {
  mutation: MutationType;
  node: Apply;
  updatedFields: String[];
  previousValues: ApplyPreviousValues;
}

export interface ApplySubscriptionPayloadPromise
  extends Promise<ApplySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplyPreviousValuesPromise>() => T;
}

export interface ApplySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplyPreviousValuesSubscription>() => T;
}

export interface ApplyPreviousValues {
  seq: Int;
}

export interface ApplyPreviousValuesPromise
  extends Promise<ApplyPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
}

export interface ApplyPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplyPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
}

export interface MatchSubscriptionPayload {
  mutation: MutationType;
  node: Match;
  updatedFields: String[];
  previousValues: MatchPreviousValues;
}

export interface MatchSubscriptionPayloadPromise
  extends Promise<MatchSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MatchPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MatchPreviousValuesPromise>() => T;
}

export interface MatchSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MatchSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MatchSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MatchPreviousValuesSubscription>() => T;
}

export interface MatchPreviousValues {
  seq: Int;
  status: Status;
  stadium: String;
  address?: String;
  area: Area;
  date: String;
  startTime: String;
  endTime: String;
  description?: String;
  result?: Result;
}

export interface MatchPreviousValuesPromise
  extends Promise<MatchPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  status: () => Promise<Status>;
  stadium: () => Promise<String>;
  address: () => Promise<String>;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  description: () => Promise<String>;
  result: () => Promise<Result>;
}

export interface MatchPreviousValuesSubscription
  extends Promise<AsyncIterator<MatchPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Status>>;
  stadium: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<Area>>;
  date: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<Result>>;
}

export interface NotifierSubscriptionPayload {
  mutation: MutationType;
  node: Notifier;
  updatedFields: String[];
  previousValues: NotifierPreviousValues;
}

export interface NotifierSubscriptionPayloadPromise
  extends Promise<NotifierSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotifierPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotifierPreviousValuesPromise>() => T;
}

export interface NotifierSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotifierSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotifierSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotifierPreviousValuesSubscription>() => T;
}

export interface NotifierPreviousValues {
  seq: Int;
  area: Area[];
  date?: String;
  startTime?: String;
  endTime?: String;
}

export interface NotifierPreviousValuesPromise
  extends Promise<NotifierPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  area: () => Promise<Area[]>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
}

export interface NotifierPreviousValuesSubscription
  extends Promise<AsyncIterator<NotifierPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  area: () => Promise<AsyncIterator<Area[]>>;
  date: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
}

export interface PlayerSubscriptionPayload {
  mutation: MutationType;
  node: Player;
  updatedFields: String[];
  previousValues: PlayerPreviousValues;
}

export interface PlayerSubscriptionPayloadPromise
  extends Promise<PlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlayerPreviousValuesPromise>() => T;
}

export interface PlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlayerPreviousValuesSubscription>() => T;
}

export interface PlayerPreviousValues {
  seq: Int;
  playerId: String;
  name?: String;
  phone?: String;
  email?: String;
  authProvider: Auth;
}

export interface PlayerPreviousValuesPromise
  extends Promise<PlayerPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  playerId: () => Promise<String>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  authProvider: () => Promise<Auth>;
}

export interface PlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<PlayerPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  playerId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  authProvider: () => Promise<AsyncIterator<Auth>>;
}

export interface StadiumSubscriptionPayload {
  mutation: MutationType;
  node: Stadium;
  updatedFields: String[];
  previousValues: StadiumPreviousValues;
}

export interface StadiumSubscriptionPayloadPromise
  extends Promise<StadiumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StadiumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StadiumPreviousValuesPromise>() => T;
}

export interface StadiumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StadiumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StadiumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StadiumPreviousValuesSubscription>() => T;
}

export interface StadiumPreviousValues {
  seq: Int;
  name?: String;
  address?: String;
}

export interface StadiumPreviousValuesPromise
  extends Promise<StadiumPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface StadiumPreviousValuesSubscription
  extends Promise<AsyncIterator<StadiumPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface TeamPreviousValues {
  seq: Int;
  name: String;
  logo?: String;
  homeArea?: Area;
  introduction?: String;
  win: Int;
  draw: Int;
  lose: Int;
  rating: Int;
  teamUniqueId: String;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  logo: () => Promise<String>;
  homeArea: () => Promise<Area>;
  introduction: () => Promise<String>;
  win: () => Promise<Int>;
  draw: () => Promise<Int>;
  lose: () => Promise<Int>;
  rating: () => Promise<Int>;
  teamUniqueId: () => Promise<String>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  homeArea: () => Promise<AsyncIterator<Area>>;
  introduction: () => Promise<AsyncIterator<String>>;
  win: () => Promise<AsyncIterator<Int>>;
  draw: () => Promise<AsyncIterator<Int>>;
  lose: () => Promise<AsyncIterator<Int>>;
  rating: () => Promise<AsyncIterator<Int>>;
  teamUniqueId: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Team",
    embedded: false
  },
  {
    name: "Player",
    embedded: false
  },
  {
    name: "Auth",
    embedded: false
  },
  {
    name: "Result",
    embedded: false
  },
  {
    name: "Area",
    embedded: false
  },
  {
    name: "Match",
    embedded: false
  },
  {
    name: "Status",
    embedded: false
  },
  {
    name: "Apply",
    embedded: false
  },
  {
    name: "Notifier",
    embedded: false
  },
  {
    name: "Stadium",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
