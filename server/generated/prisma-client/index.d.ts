// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  apply: (where?: ApplyWhereInput) => Promise<boolean>;
  match: (where?: MatchWhereInput) => Promise<boolean>;
  notifier: (where?: NotifierWhereInput) => Promise<boolean>;
  player: (where?: PlayerWhereInput) => Promise<boolean>;
  stadium: (where?: StadiumWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  apply: (where: ApplyWhereUniqueInput) => ApplyNullablePromise;
  applies: (args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Apply>;
  appliesConnection: (args?: {
    where?: ApplyWhereInput;
    orderBy?: ApplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplyConnectionPromise;
  match: (where: MatchWhereUniqueInput) => MatchNullablePromise;
  matches: (args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Match>;
  matchesConnection: (args?: {
    where?: MatchWhereInput;
    orderBy?: MatchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MatchConnectionPromise;
  notifier: (where: NotifierWhereUniqueInput) => NotifierNullablePromise;
  notifiers: (args?: {
    where?: NotifierWhereInput;
    orderBy?: NotifierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notifier>;
  notifiersConnection: (args?: {
    where?: NotifierWhereInput;
    orderBy?: NotifierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotifierConnectionPromise;
  player: (where: PlayerWhereUniqueInput) => PlayerNullablePromise;
  players: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Player>;
  playersConnection: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlayerConnectionPromise;
  stadium: (where: StadiumWhereUniqueInput) => StadiumNullablePromise;
  stadiums: (args?: {
    where?: StadiumWhereInput;
    orderBy?: StadiumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Stadium>;
  stadiumsConnection: (args?: {
    where?: StadiumWhereInput;
    orderBy?: StadiumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StadiumConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamNullablePromise;
  teams: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Team>;
  teamsConnection: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeamConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApply: (data: ApplyCreateInput) => ApplyPromise;
  updateApply: (args: {
    data: ApplyUpdateInput;
    where: ApplyWhereUniqueInput;
  }) => ApplyPromise;
  upsertApply: (args: {
    where: ApplyWhereUniqueInput;
    create: ApplyCreateInput;
    update: ApplyUpdateInput;
  }) => ApplyPromise;
  deleteApply: (where: ApplyWhereUniqueInput) => ApplyPromise;
  deleteManyApplies: (where?: ApplyWhereInput) => BatchPayloadPromise;
  createMatch: (data: MatchCreateInput) => MatchPromise;
  updateMatch: (args: {
    data: MatchUpdateInput;
    where: MatchWhereUniqueInput;
  }) => MatchPromise;
  updateManyMatches: (args: {
    data: MatchUpdateManyMutationInput;
    where?: MatchWhereInput;
  }) => BatchPayloadPromise;
  upsertMatch: (args: {
    where: MatchWhereUniqueInput;
    create: MatchCreateInput;
    update: MatchUpdateInput;
  }) => MatchPromise;
  deleteMatch: (where: MatchWhereUniqueInput) => MatchPromise;
  deleteManyMatches: (where?: MatchWhereInput) => BatchPayloadPromise;
  createNotifier: (data: NotifierCreateInput) => NotifierPromise;
  updateNotifier: (args: {
    data: NotifierUpdateInput;
    where: NotifierWhereUniqueInput;
  }) => NotifierPromise;
  updateManyNotifiers: (args: {
    data: NotifierUpdateManyMutationInput;
    where?: NotifierWhereInput;
  }) => BatchPayloadPromise;
  upsertNotifier: (args: {
    where: NotifierWhereUniqueInput;
    create: NotifierCreateInput;
    update: NotifierUpdateInput;
  }) => NotifierPromise;
  deleteNotifier: (where: NotifierWhereUniqueInput) => NotifierPromise;
  deleteManyNotifiers: (where?: NotifierWhereInput) => BatchPayloadPromise;
  createPlayer: (data: PlayerCreateInput) => PlayerPromise;
  updatePlayer: (args: {
    data: PlayerUpdateInput;
    where: PlayerWhereUniqueInput;
  }) => PlayerPromise;
  updateManyPlayers: (args: {
    data: PlayerUpdateManyMutationInput;
    where?: PlayerWhereInput;
  }) => BatchPayloadPromise;
  upsertPlayer: (args: {
    where: PlayerWhereUniqueInput;
    create: PlayerCreateInput;
    update: PlayerUpdateInput;
  }) => PlayerPromise;
  deletePlayer: (where: PlayerWhereUniqueInput) => PlayerPromise;
  deleteManyPlayers: (where?: PlayerWhereInput) => BatchPayloadPromise;
  createStadium: (data: StadiumCreateInput) => StadiumPromise;
  updateStadium: (args: {
    data: StadiumUpdateInput;
    where: StadiumWhereUniqueInput;
  }) => StadiumPromise;
  updateManyStadiums: (args: {
    data: StadiumUpdateManyMutationInput;
    where?: StadiumWhereInput;
  }) => BatchPayloadPromise;
  upsertStadium: (args: {
    where: StadiumWhereUniqueInput;
    create: StadiumCreateInput;
    update: StadiumUpdateInput;
  }) => StadiumPromise;
  deleteStadium: (where: StadiumWhereUniqueInput) => StadiumPromise;
  deleteManyStadiums: (where?: StadiumWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (args: {
    data: TeamUpdateInput;
    where: TeamWhereUniqueInput;
  }) => TeamPromise;
  updateManyTeams: (args: {
    data: TeamUpdateManyMutationInput;
    where?: TeamWhereInput;
  }) => BatchPayloadPromise;
  upsertTeam: (args: {
    where: TeamWhereUniqueInput;
    create: TeamCreateInput;
    update: TeamUpdateInput;
  }) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  apply: (
    where?: ApplySubscriptionWhereInput
  ) => ApplySubscriptionPayloadSubscription;
  match: (
    where?: MatchSubscriptionWhereInput
  ) => MatchSubscriptionPayloadSubscription;
  notifier: (
    where?: NotifierSubscriptionWhereInput
  ) => NotifierSubscriptionPayloadSubscription;
  player: (
    where?: PlayerSubscriptionWhereInput
  ) => PlayerSubscriptionPayloadSubscription;
  stadium: (
    where?: StadiumSubscriptionWhereInput
  ) => StadiumSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Area = "SB" | "SN" | "DN" | "DB";

export type Result = "WIN" | "DRAW" | "LOSE";

export type ApplyOrderByInput = "seq_ASC" | "seq_DESC";

export type MatchOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "stadium_ASC"
  | "stadium_DESC"
  | "area_ASC"
  | "area_DESC"
  | "date_ASC"
  | "date_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "description_ASC"
  | "description_DESC"
  | "result_ASC"
  | "result_DESC";

export type NotifierOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "area_ASC"
  | "area_DESC"
  | "date_ASC"
  | "date_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC";

export type PlayerOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "playerId_ASC"
  | "playerId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC";

export type StadiumOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC";

export type TeamOrderByInput =
  | "seq_ASC"
  | "seq_DESC"
  | "name_ASC"
  | "name_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "home_area_ASC"
  | "home_area_DESC"
  | "introduction_ASC"
  | "introduction_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ApplyWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export interface ApplyWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  team?: Maybe<TeamWhereInput>;
  match?: Maybe<MatchWhereInput>;
  AND?: Maybe<ApplyWhereInput[] | ApplyWhereInput>;
  OR?: Maybe<ApplyWhereInput[] | ApplyWhereInput>;
  NOT?: Maybe<ApplyWhereInput[] | ApplyWhereInput>;
}

export interface TeamWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  home_area?: Maybe<Area>;
  home_area_not?: Maybe<Area>;
  home_area_in?: Maybe<Area[] | Area>;
  home_area_not_in?: Maybe<Area[] | Area>;
  introduction?: Maybe<String>;
  introduction_not?: Maybe<String>;
  introduction_in?: Maybe<String[] | String>;
  introduction_not_in?: Maybe<String[] | String>;
  introduction_lt?: Maybe<String>;
  introduction_lte?: Maybe<String>;
  introduction_gt?: Maybe<String>;
  introduction_gte?: Maybe<String>;
  introduction_contains?: Maybe<String>;
  introduction_not_contains?: Maybe<String>;
  introduction_starts_with?: Maybe<String>;
  introduction_not_starts_with?: Maybe<String>;
  introduction_ends_with?: Maybe<String>;
  introduction_not_ends_with?: Maybe<String>;
  AND?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  OR?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  NOT?: Maybe<TeamWhereInput[] | TeamWhereInput>;
}

export interface MatchWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  host?: Maybe<TeamWhereInput>;
  guest?: Maybe<TeamWhereInput>;
  stadium?: Maybe<String>;
  stadium_not?: Maybe<String>;
  stadium_in?: Maybe<String[] | String>;
  stadium_not_in?: Maybe<String[] | String>;
  stadium_lt?: Maybe<String>;
  stadium_lte?: Maybe<String>;
  stadium_gt?: Maybe<String>;
  stadium_gte?: Maybe<String>;
  stadium_contains?: Maybe<String>;
  stadium_not_contains?: Maybe<String>;
  stadium_starts_with?: Maybe<String>;
  stadium_not_starts_with?: Maybe<String>;
  stadium_ends_with?: Maybe<String>;
  stadium_not_ends_with?: Maybe<String>;
  area?: Maybe<Area>;
  area_not?: Maybe<Area>;
  area_in?: Maybe<Area[] | Area>;
  area_not_in?: Maybe<Area[] | Area>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  result?: Maybe<Result>;
  result_not?: Maybe<Result>;
  result_in?: Maybe<Result[] | Result>;
  result_not_in?: Maybe<Result[] | Result>;
  AND?: Maybe<MatchWhereInput[] | MatchWhereInput>;
  OR?: Maybe<MatchWhereInput[] | MatchWhereInput>;
  NOT?: Maybe<MatchWhereInput[] | MatchWhereInput>;
}

export type MatchWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export type NotifierWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export interface NotifierWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  player?: Maybe<PlayerWhereInput>;
  area?: Maybe<Area>;
  area_not?: Maybe<Area>;
  area_in?: Maybe<Area[] | Area>;
  area_not_in?: Maybe<Area[] | Area>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  AND?: Maybe<NotifierWhereInput[] | NotifierWhereInput>;
  OR?: Maybe<NotifierWhereInput[] | NotifierWhereInput>;
  NOT?: Maybe<NotifierWhereInput[] | NotifierWhereInput>;
}

export interface PlayerWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  playerId?: Maybe<String>;
  playerId_not?: Maybe<String>;
  playerId_in?: Maybe<String[] | String>;
  playerId_not_in?: Maybe<String[] | String>;
  playerId_lt?: Maybe<String>;
  playerId_lte?: Maybe<String>;
  playerId_gt?: Maybe<String>;
  playerId_gte?: Maybe<String>;
  playerId_contains?: Maybe<String>;
  playerId_not_contains?: Maybe<String>;
  playerId_starts_with?: Maybe<String>;
  playerId_not_starts_with?: Maybe<String>;
  playerId_ends_with?: Maybe<String>;
  playerId_not_ends_with?: Maybe<String>;
  team?: Maybe<TeamWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  AND?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
  OR?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
  NOT?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
}

export type PlayerWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
  playerId?: Maybe<String>;
}>;

export type StadiumWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export interface StadiumWhereInput {
  seq?: Maybe<Int>;
  seq_not?: Maybe<Int>;
  seq_in?: Maybe<Int[] | Int>;
  seq_not_in?: Maybe<Int[] | Int>;
  seq_lt?: Maybe<Int>;
  seq_lte?: Maybe<Int>;
  seq_gt?: Maybe<Int>;
  seq_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  AND?: Maybe<StadiumWhereInput[] | StadiumWhereInput>;
  OR?: Maybe<StadiumWhereInput[] | StadiumWhereInput>;
  NOT?: Maybe<StadiumWhereInput[] | StadiumWhereInput>;
}

export type TeamWhereUniqueInput = AtLeastOne<{
  seq: Maybe<Int>;
}>;

export interface ApplyCreateInput {
  seq?: Maybe<Int>;
  team?: Maybe<TeamCreateOneInput>;
  match?: Maybe<MatchCreateOneInput>;
}

export interface TeamCreateOneInput {
  create?: Maybe<TeamCreateInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamCreateInput {
  seq?: Maybe<Int>;
  name: String;
  logo?: Maybe<String>;
  home_area?: Maybe<Area>;
  introduction?: Maybe<String>;
}

export interface MatchCreateOneInput {
  create?: Maybe<MatchCreateInput>;
  connect?: Maybe<MatchWhereUniqueInput>;
}

export interface MatchCreateInput {
  seq?: Maybe<Int>;
  host?: Maybe<TeamCreateOneInput>;
  guest?: Maybe<TeamCreateOneInput>;
  stadium: String;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface ApplyUpdateInput {
  team?: Maybe<TeamUpdateOneInput>;
  match?: Maybe<MatchUpdateOneInput>;
}

export interface TeamUpdateOneInput {
  create?: Maybe<TeamCreateInput>;
  update?: Maybe<TeamUpdateDataInput>;
  upsert?: Maybe<TeamUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface TeamUpdateDataInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  home_area?: Maybe<Area>;
  introduction?: Maybe<String>;
}

export interface TeamUpsertNestedInput {
  update: TeamUpdateDataInput;
  create: TeamCreateInput;
}

export interface MatchUpdateOneInput {
  create?: Maybe<MatchCreateInput>;
  update?: Maybe<MatchUpdateDataInput>;
  upsert?: Maybe<MatchUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MatchWhereUniqueInput>;
}

export interface MatchUpdateDataInput {
  host?: Maybe<TeamUpdateOneInput>;
  guest?: Maybe<TeamUpdateOneInput>;
  stadium?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface MatchUpsertNestedInput {
  update: MatchUpdateDataInput;
  create: MatchCreateInput;
}

export interface MatchUpdateInput {
  host?: Maybe<TeamUpdateOneInput>;
  guest?: Maybe<TeamUpdateOneInput>;
  stadium?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface MatchUpdateManyMutationInput {
  stadium?: Maybe<String>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  description?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface NotifierCreateInput {
  seq?: Maybe<Int>;
  player: PlayerCreateOneInput;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface PlayerCreateOneInput {
  create?: Maybe<PlayerCreateInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerCreateInput {
  seq?: Maybe<Int>;
  playerId: String;
  team?: Maybe<TeamCreateOneInput>;
  name: String;
  phone?: Maybe<String>;
}

export interface NotifierUpdateInput {
  player?: Maybe<PlayerUpdateOneRequiredInput>;
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface PlayerUpdateOneRequiredInput {
  create?: Maybe<PlayerCreateInput>;
  update?: Maybe<PlayerUpdateDataInput>;
  upsert?: Maybe<PlayerUpsertNestedInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerUpdateDataInput {
  playerId?: Maybe<String>;
  team?: Maybe<TeamUpdateOneInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface PlayerUpsertNestedInput {
  update: PlayerUpdateDataInput;
  create: PlayerCreateInput;
}

export interface NotifierUpdateManyMutationInput {
  area?: Maybe<Area>;
  date?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
}

export interface PlayerUpdateInput {
  playerId?: Maybe<String>;
  team?: Maybe<TeamUpdateOneInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface PlayerUpdateManyMutationInput {
  playerId?: Maybe<String>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface StadiumCreateInput {
  seq?: Maybe<Int>;
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface StadiumUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface StadiumUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface TeamUpdateInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  home_area?: Maybe<Area>;
  introduction?: Maybe<String>;
}

export interface TeamUpdateManyMutationInput {
  name?: Maybe<String>;
  logo?: Maybe<String>;
  home_area?: Maybe<Area>;
  introduction?: Maybe<String>;
}

export interface ApplySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplyWhereInput>;
  AND?: Maybe<ApplySubscriptionWhereInput[] | ApplySubscriptionWhereInput>;
  OR?: Maybe<ApplySubscriptionWhereInput[] | ApplySubscriptionWhereInput>;
  NOT?: Maybe<ApplySubscriptionWhereInput[] | ApplySubscriptionWhereInput>;
}

export interface MatchSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MatchWhereInput>;
  AND?: Maybe<MatchSubscriptionWhereInput[] | MatchSubscriptionWhereInput>;
  OR?: Maybe<MatchSubscriptionWhereInput[] | MatchSubscriptionWhereInput>;
  NOT?: Maybe<MatchSubscriptionWhereInput[] | MatchSubscriptionWhereInput>;
}

export interface NotifierSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NotifierWhereInput>;
  AND?: Maybe<
    NotifierSubscriptionWhereInput[] | NotifierSubscriptionWhereInput
  >;
  OR?: Maybe<NotifierSubscriptionWhereInput[] | NotifierSubscriptionWhereInput>;
  NOT?: Maybe<
    NotifierSubscriptionWhereInput[] | NotifierSubscriptionWhereInput
  >;
}

export interface PlayerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlayerWhereInput>;
  AND?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
  OR?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
  NOT?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
}

export interface StadiumSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StadiumWhereInput>;
  AND?: Maybe<StadiumSubscriptionWhereInput[] | StadiumSubscriptionWhereInput>;
  OR?: Maybe<StadiumSubscriptionWhereInput[] | StadiumSubscriptionWhereInput>;
  NOT?: Maybe<StadiumSubscriptionWhereInput[] | StadiumSubscriptionWhereInput>;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TeamWhereInput>;
  AND?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  OR?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  NOT?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Apply {
  seq: Int;
}

export interface ApplyPromise extends Promise<Apply>, Fragmentable {
  seq: () => Promise<Int>;
  team: <T = TeamPromise>() => T;
  match: <T = MatchPromise>() => T;
}

export interface ApplySubscription
  extends Promise<AsyncIterator<Apply>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  team: <T = TeamSubscription>() => T;
  match: <T = MatchSubscription>() => T;
}

export interface ApplyNullablePromise
  extends Promise<Apply | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  team: <T = TeamPromise>() => T;
  match: <T = MatchPromise>() => T;
}

export interface Team {
  seq: Int;
  name: String;
  logo?: String;
  home_area?: Area;
  introduction?: String;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  logo: () => Promise<String>;
  home_area: () => Promise<Area>;
  introduction: () => Promise<String>;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  home_area: () => Promise<AsyncIterator<Area>>;
  introduction: () => Promise<AsyncIterator<String>>;
}

export interface TeamNullablePromise
  extends Promise<Team | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  logo: () => Promise<String>;
  home_area: () => Promise<Area>;
  introduction: () => Promise<String>;
}

export interface Match {
  seq: Int;
  stadium: String;
  area?: Area;
  date?: String;
  startTime?: String;
  endTime?: String;
  description?: String;
  result?: Result;
}

export interface MatchPromise extends Promise<Match>, Fragmentable {
  seq: () => Promise<Int>;
  host: <T = TeamPromise>() => T;
  guest: <T = TeamPromise>() => T;
  stadium: () => Promise<String>;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  description: () => Promise<String>;
  result: () => Promise<Result>;
}

export interface MatchSubscription
  extends Promise<AsyncIterator<Match>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  host: <T = TeamSubscription>() => T;
  guest: <T = TeamSubscription>() => T;
  stadium: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<Area>>;
  date: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<Result>>;
}

export interface MatchNullablePromise
  extends Promise<Match | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  host: <T = TeamPromise>() => T;
  guest: <T = TeamPromise>() => T;
  stadium: () => Promise<String>;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  description: () => Promise<String>;
  result: () => Promise<Result>;
}

export interface ApplyConnection {
  pageInfo: PageInfo;
  edges: ApplyEdge[];
}

export interface ApplyConnectionPromise
  extends Promise<ApplyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplyEdge>>() => T;
  aggregate: <T = AggregateApplyPromise>() => T;
}

export interface ApplyConnectionSubscription
  extends Promise<AsyncIterator<ApplyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplyEdge {
  node: Apply;
  cursor: String;
}

export interface ApplyEdgePromise extends Promise<ApplyEdge>, Fragmentable {
  node: <T = ApplyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplyEdgeSubscription
  extends Promise<AsyncIterator<ApplyEdge>>,
    Fragmentable {
  node: <T = ApplySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApply {
  count: Int;
}

export interface AggregateApplyPromise
  extends Promise<AggregateApply>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplySubscription
  extends Promise<AsyncIterator<AggregateApply>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MatchConnection {
  pageInfo: PageInfo;
  edges: MatchEdge[];
}

export interface MatchConnectionPromise
  extends Promise<MatchConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MatchEdge>>() => T;
  aggregate: <T = AggregateMatchPromise>() => T;
}

export interface MatchConnectionSubscription
  extends Promise<AsyncIterator<MatchConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MatchEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMatchSubscription>() => T;
}

export interface MatchEdge {
  node: Match;
  cursor: String;
}

export interface MatchEdgePromise extends Promise<MatchEdge>, Fragmentable {
  node: <T = MatchPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MatchEdgeSubscription
  extends Promise<AsyncIterator<MatchEdge>>,
    Fragmentable {
  node: <T = MatchSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMatch {
  count: Int;
}

export interface AggregateMatchPromise
  extends Promise<AggregateMatch>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMatchSubscription
  extends Promise<AsyncIterator<AggregateMatch>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Notifier {
  seq: Int;
  area?: Area;
  date?: String;
  startTime?: String;
  endTime?: String;
}

export interface NotifierPromise extends Promise<Notifier>, Fragmentable {
  seq: () => Promise<Int>;
  player: <T = PlayerPromise>() => T;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
}

export interface NotifierSubscription
  extends Promise<AsyncIterator<Notifier>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  player: <T = PlayerSubscription>() => T;
  area: () => Promise<AsyncIterator<Area>>;
  date: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
}

export interface NotifierNullablePromise
  extends Promise<Notifier | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  player: <T = PlayerPromise>() => T;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
}

export interface Player {
  seq: Int;
  playerId: String;
  name: String;
  phone?: String;
}

export interface PlayerPromise extends Promise<Player>, Fragmentable {
  seq: () => Promise<Int>;
  playerId: () => Promise<String>;
  team: <T = TeamPromise>() => T;
  name: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface PlayerSubscription
  extends Promise<AsyncIterator<Player>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  playerId: () => Promise<AsyncIterator<String>>;
  team: <T = TeamSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface PlayerNullablePromise
  extends Promise<Player | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  playerId: () => Promise<String>;
  team: <T = TeamPromise>() => T;
  name: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface NotifierConnection {
  pageInfo: PageInfo;
  edges: NotifierEdge[];
}

export interface NotifierConnectionPromise
  extends Promise<NotifierConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotifierEdge>>() => T;
  aggregate: <T = AggregateNotifierPromise>() => T;
}

export interface NotifierConnectionSubscription
  extends Promise<AsyncIterator<NotifierConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotifierEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotifierSubscription>() => T;
}

export interface NotifierEdge {
  node: Notifier;
  cursor: String;
}

export interface NotifierEdgePromise
  extends Promise<NotifierEdge>,
    Fragmentable {
  node: <T = NotifierPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotifierEdgeSubscription
  extends Promise<AsyncIterator<NotifierEdge>>,
    Fragmentable {
  node: <T = NotifierSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotifier {
  count: Int;
}

export interface AggregateNotifierPromise
  extends Promise<AggregateNotifier>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotifierSubscription
  extends Promise<AsyncIterator<AggregateNotifier>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlayerConnection {
  pageInfo: PageInfo;
  edges: PlayerEdge[];
}

export interface PlayerConnectionPromise
  extends Promise<PlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlayerEdge>>() => T;
  aggregate: <T = AggregatePlayerPromise>() => T;
}

export interface PlayerConnectionSubscription
  extends Promise<AsyncIterator<PlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlayerSubscription>() => T;
}

export interface PlayerEdge {
  node: Player;
  cursor: String;
}

export interface PlayerEdgePromise extends Promise<PlayerEdge>, Fragmentable {
  node: <T = PlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlayerEdgeSubscription
  extends Promise<AsyncIterator<PlayerEdge>>,
    Fragmentable {
  node: <T = PlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlayer {
  count: Int;
}

export interface AggregatePlayerPromise
  extends Promise<AggregatePlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlayerSubscription
  extends Promise<AsyncIterator<AggregatePlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Stadium {
  seq: Int;
  name?: String;
  address?: String;
}

export interface StadiumPromise extends Promise<Stadium>, Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface StadiumSubscription
  extends Promise<AsyncIterator<Stadium>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface StadiumNullablePromise
  extends Promise<Stadium | null>,
    Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface StadiumConnection {
  pageInfo: PageInfo;
  edges: StadiumEdge[];
}

export interface StadiumConnectionPromise
  extends Promise<StadiumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StadiumEdge>>() => T;
  aggregate: <T = AggregateStadiumPromise>() => T;
}

export interface StadiumConnectionSubscription
  extends Promise<AsyncIterator<StadiumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StadiumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStadiumSubscription>() => T;
}

export interface StadiumEdge {
  node: Stadium;
  cursor: String;
}

export interface StadiumEdgePromise extends Promise<StadiumEdge>, Fragmentable {
  node: <T = StadiumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StadiumEdgeSubscription
  extends Promise<AsyncIterator<StadiumEdge>>,
    Fragmentable {
  node: <T = StadiumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStadium {
  count: Int;
}

export interface AggregateStadiumPromise
  extends Promise<AggregateStadium>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStadiumSubscription
  extends Promise<AsyncIterator<AggregateStadium>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ApplySubscriptionPayload {
  mutation: MutationType;
  node: Apply;
  updatedFields: String[];
  previousValues: ApplyPreviousValues;
}

export interface ApplySubscriptionPayloadPromise
  extends Promise<ApplySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplyPreviousValuesPromise>() => T;
}

export interface ApplySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplyPreviousValuesSubscription>() => T;
}

export interface ApplyPreviousValues {
  seq: Int;
}

export interface ApplyPreviousValuesPromise
  extends Promise<ApplyPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
}

export interface ApplyPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplyPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
}

export interface MatchSubscriptionPayload {
  mutation: MutationType;
  node: Match;
  updatedFields: String[];
  previousValues: MatchPreviousValues;
}

export interface MatchSubscriptionPayloadPromise
  extends Promise<MatchSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MatchPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MatchPreviousValuesPromise>() => T;
}

export interface MatchSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MatchSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MatchSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MatchPreviousValuesSubscription>() => T;
}

export interface MatchPreviousValues {
  seq: Int;
  stadium: String;
  area?: Area;
  date?: String;
  startTime?: String;
  endTime?: String;
  description?: String;
  result?: Result;
}

export interface MatchPreviousValuesPromise
  extends Promise<MatchPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  stadium: () => Promise<String>;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  description: () => Promise<String>;
  result: () => Promise<Result>;
}

export interface MatchPreviousValuesSubscription
  extends Promise<AsyncIterator<MatchPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  stadium: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<Area>>;
  date: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<Result>>;
}

export interface NotifierSubscriptionPayload {
  mutation: MutationType;
  node: Notifier;
  updatedFields: String[];
  previousValues: NotifierPreviousValues;
}

export interface NotifierSubscriptionPayloadPromise
  extends Promise<NotifierSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotifierPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotifierPreviousValuesPromise>() => T;
}

export interface NotifierSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotifierSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotifierSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotifierPreviousValuesSubscription>() => T;
}

export interface NotifierPreviousValues {
  seq: Int;
  area?: Area;
  date?: String;
  startTime?: String;
  endTime?: String;
}

export interface NotifierPreviousValuesPromise
  extends Promise<NotifierPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  area: () => Promise<Area>;
  date: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
}

export interface NotifierPreviousValuesSubscription
  extends Promise<AsyncIterator<NotifierPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  area: () => Promise<AsyncIterator<Area>>;
  date: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
}

export interface PlayerSubscriptionPayload {
  mutation: MutationType;
  node: Player;
  updatedFields: String[];
  previousValues: PlayerPreviousValues;
}

export interface PlayerSubscriptionPayloadPromise
  extends Promise<PlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlayerPreviousValuesPromise>() => T;
}

export interface PlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlayerPreviousValuesSubscription>() => T;
}

export interface PlayerPreviousValues {
  seq: Int;
  playerId: String;
  name: String;
  phone?: String;
}

export interface PlayerPreviousValuesPromise
  extends Promise<PlayerPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  playerId: () => Promise<String>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface PlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<PlayerPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  playerId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface StadiumSubscriptionPayload {
  mutation: MutationType;
  node: Stadium;
  updatedFields: String[];
  previousValues: StadiumPreviousValues;
}

export interface StadiumSubscriptionPayloadPromise
  extends Promise<StadiumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StadiumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StadiumPreviousValuesPromise>() => T;
}

export interface StadiumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StadiumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StadiumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StadiumPreviousValuesSubscription>() => T;
}

export interface StadiumPreviousValues {
  seq: Int;
  name?: String;
  address?: String;
}

export interface StadiumPreviousValuesPromise
  extends Promise<StadiumPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface StadiumPreviousValuesSubscription
  extends Promise<AsyncIterator<StadiumPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface TeamPreviousValues {
  seq: Int;
  name: String;
  logo?: String;
  home_area?: Area;
  introduction?: String;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  seq: () => Promise<Int>;
  name: () => Promise<String>;
  logo: () => Promise<String>;
  home_area: () => Promise<Area>;
  introduction: () => Promise<String>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  seq: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  home_area: () => Promise<AsyncIterator<Area>>;
  introduction: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Team",
    embedded: false
  },
  {
    name: "Player",
    embedded: false
  },
  {
    name: "Result",
    embedded: false
  },
  {
    name: "Area",
    embedded: false
  },
  {
    name: "Match",
    embedded: false
  },
  {
    name: "Apply",
    embedded: false
  },
  {
    name: "Notifier",
    embedded: false
  },
  {
    name: "Stadium",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
