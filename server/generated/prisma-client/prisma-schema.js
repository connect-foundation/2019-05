module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateApply {
  count: Int!
}

type AggregateMatch {
  count: Int!
}

type AggregateNotifier {
  count: Int!
}

type AggregatePlayer {
  count: Int!
}

type AggregateStadium {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type Apply {
  seq: Int!
  team: Team
  player: Player
  match: Match
}

type ApplyConnection {
  pageInfo: PageInfo!
  edges: [ApplyEdge]!
  aggregate: AggregateApply!
}

input ApplyCreateInput {
  seq: Int
  team: TeamCreateOneWithoutOnApplyingListInput
  player: PlayerCreateOneWithoutApplyingListInput
  match: MatchCreateOneWithoutAppliedListsInput
}

input ApplyCreateManyWithoutMatchInput {
  create: [ApplyCreateWithoutMatchInput!]
  connect: [ApplyWhereUniqueInput!]
}

input ApplyCreateManyWithoutPlayerInput {
  create: [ApplyCreateWithoutPlayerInput!]
  connect: [ApplyWhereUniqueInput!]
}

input ApplyCreateManyWithoutTeamInput {
  create: [ApplyCreateWithoutTeamInput!]
  connect: [ApplyWhereUniqueInput!]
}

input ApplyCreateWithoutMatchInput {
  seq: Int
  team: TeamCreateOneWithoutOnApplyingListInput
  player: PlayerCreateOneWithoutApplyingListInput
}

input ApplyCreateWithoutPlayerInput {
  seq: Int
  team: TeamCreateOneWithoutOnApplyingListInput
  match: MatchCreateOneWithoutAppliedListsInput
}

input ApplyCreateWithoutTeamInput {
  seq: Int
  player: PlayerCreateOneWithoutApplyingListInput
  match: MatchCreateOneWithoutAppliedListsInput
}

type ApplyEdge {
  node: Apply!
  cursor: String!
}

enum ApplyOrderByInput {
  seq_ASC
  seq_DESC
}

type ApplyPreviousValues {
  seq: Int!
}

input ApplyScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  AND: [ApplyScalarWhereInput!]
  OR: [ApplyScalarWhereInput!]
  NOT: [ApplyScalarWhereInput!]
}

type ApplySubscriptionPayload {
  mutation: MutationType!
  node: Apply
  updatedFields: [String!]
  previousValues: ApplyPreviousValues
}

input ApplySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ApplyWhereInput
  AND: [ApplySubscriptionWhereInput!]
  OR: [ApplySubscriptionWhereInput!]
  NOT: [ApplySubscriptionWhereInput!]
}

input ApplyUpdateInput {
  team: TeamUpdateOneWithoutOnApplyingListInput
  player: PlayerUpdateOneWithoutApplyingListInput
  match: MatchUpdateOneWithoutAppliedListsInput
}

input ApplyUpdateManyWithoutMatchInput {
  create: [ApplyCreateWithoutMatchInput!]
  delete: [ApplyWhereUniqueInput!]
  connect: [ApplyWhereUniqueInput!]
  set: [ApplyWhereUniqueInput!]
  disconnect: [ApplyWhereUniqueInput!]
  update: [ApplyUpdateWithWhereUniqueWithoutMatchInput!]
  upsert: [ApplyUpsertWithWhereUniqueWithoutMatchInput!]
  deleteMany: [ApplyScalarWhereInput!]
}

input ApplyUpdateManyWithoutPlayerInput {
  create: [ApplyCreateWithoutPlayerInput!]
  delete: [ApplyWhereUniqueInput!]
  connect: [ApplyWhereUniqueInput!]
  set: [ApplyWhereUniqueInput!]
  disconnect: [ApplyWhereUniqueInput!]
  update: [ApplyUpdateWithWhereUniqueWithoutPlayerInput!]
  upsert: [ApplyUpsertWithWhereUniqueWithoutPlayerInput!]
  deleteMany: [ApplyScalarWhereInput!]
}

input ApplyUpdateManyWithoutTeamInput {
  create: [ApplyCreateWithoutTeamInput!]
  delete: [ApplyWhereUniqueInput!]
  connect: [ApplyWhereUniqueInput!]
  set: [ApplyWhereUniqueInput!]
  disconnect: [ApplyWhereUniqueInput!]
  update: [ApplyUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [ApplyUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [ApplyScalarWhereInput!]
}

input ApplyUpdateWithoutMatchDataInput {
  team: TeamUpdateOneWithoutOnApplyingListInput
  player: PlayerUpdateOneWithoutApplyingListInput
}

input ApplyUpdateWithoutPlayerDataInput {
  team: TeamUpdateOneWithoutOnApplyingListInput
  match: MatchUpdateOneWithoutAppliedListsInput
}

input ApplyUpdateWithoutTeamDataInput {
  player: PlayerUpdateOneWithoutApplyingListInput
  match: MatchUpdateOneWithoutAppliedListsInput
}

input ApplyUpdateWithWhereUniqueWithoutMatchInput {
  where: ApplyWhereUniqueInput!
  data: ApplyUpdateWithoutMatchDataInput!
}

input ApplyUpdateWithWhereUniqueWithoutPlayerInput {
  where: ApplyWhereUniqueInput!
  data: ApplyUpdateWithoutPlayerDataInput!
}

input ApplyUpdateWithWhereUniqueWithoutTeamInput {
  where: ApplyWhereUniqueInput!
  data: ApplyUpdateWithoutTeamDataInput!
}

input ApplyUpsertWithWhereUniqueWithoutMatchInput {
  where: ApplyWhereUniqueInput!
  update: ApplyUpdateWithoutMatchDataInput!
  create: ApplyCreateWithoutMatchInput!
}

input ApplyUpsertWithWhereUniqueWithoutPlayerInput {
  where: ApplyWhereUniqueInput!
  update: ApplyUpdateWithoutPlayerDataInput!
  create: ApplyCreateWithoutPlayerInput!
}

input ApplyUpsertWithWhereUniqueWithoutTeamInput {
  where: ApplyWhereUniqueInput!
  update: ApplyUpdateWithoutTeamDataInput!
  create: ApplyCreateWithoutTeamInput!
}

input ApplyWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  team: TeamWhereInput
  player: PlayerWhereInput
  match: MatchWhereInput
  AND: [ApplyWhereInput!]
  OR: [ApplyWhereInput!]
  NOT: [ApplyWhereInput!]
}

input ApplyWhereUniqueInput {
  seq: Int
}

enum Area {
  CNO
  CGS
  YSN
  SDG
  KJI
  TDM
  CNG
  SBK
  KBK
  TBG
  NWN
  UPG
  SDM
  MPO
  YGC
  KSS
  KRO
  KCN
  YDP
  TJK
  KNK
  SCO
  KNM
  SPA
  KDG
}

enum Auth {
  KAKAO
  NAVER
}

type BatchPayload {
  count: Long!
}

scalar Long

type Match {
  seq: Int!
  author: Player!
  host: Team!
  guest: Team
  status: Status!
  stadium: String!
  address: String
  area: Area!
  date: String!
  startTime: String!
  endTime: String!
  description: String
  result: Result
  appliedLists(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Apply!]
}

type MatchConnection {
  pageInfo: PageInfo!
  edges: [MatchEdge]!
  aggregate: AggregateMatch!
}

input MatchCreateInput {
  seq: Int
  author: PlayerCreateOneWithoutUploadMatchListInput!
  host: TeamCreateOneWithoutUploadMatchListInput!
  guest: TeamCreateOneWithoutMatchingDoneListInput
  status: Status!
  stadium: String!
  address: String
  area: Area!
  date: String!
  startTime: String!
  endTime: String!
  description: String
  result: Result
  appliedLists: ApplyCreateManyWithoutMatchInput
}

input MatchCreateManyWithoutAuthorInput {
  create: [MatchCreateWithoutAuthorInput!]
  connect: [MatchWhereUniqueInput!]
}

input MatchCreateManyWithoutGuestInput {
  create: [MatchCreateWithoutGuestInput!]
  connect: [MatchWhereUniqueInput!]
}

input MatchCreateManyWithoutHostInput {
  create: [MatchCreateWithoutHostInput!]
  connect: [MatchWhereUniqueInput!]
}

input MatchCreateOneWithoutAppliedListsInput {
  create: MatchCreateWithoutAppliedListsInput
  connect: MatchWhereUniqueInput
}

input MatchCreateWithoutAppliedListsInput {
  seq: Int
  author: PlayerCreateOneWithoutUploadMatchListInput!
  host: TeamCreateOneWithoutUploadMatchListInput!
  guest: TeamCreateOneWithoutMatchingDoneListInput
  status: Status!
  stadium: String!
  address: String
  area: Area!
  date: String!
  startTime: String!
  endTime: String!
  description: String
  result: Result
}

input MatchCreateWithoutAuthorInput {
  seq: Int
  host: TeamCreateOneWithoutUploadMatchListInput!
  guest: TeamCreateOneWithoutMatchingDoneListInput
  status: Status!
  stadium: String!
  address: String
  area: Area!
  date: String!
  startTime: String!
  endTime: String!
  description: String
  result: Result
  appliedLists: ApplyCreateManyWithoutMatchInput
}

input MatchCreateWithoutGuestInput {
  seq: Int
  author: PlayerCreateOneWithoutUploadMatchListInput!
  host: TeamCreateOneWithoutUploadMatchListInput!
  status: Status!
  stadium: String!
  address: String
  area: Area!
  date: String!
  startTime: String!
  endTime: String!
  description: String
  result: Result
  appliedLists: ApplyCreateManyWithoutMatchInput
}

input MatchCreateWithoutHostInput {
  seq: Int
  author: PlayerCreateOneWithoutUploadMatchListInput!
  guest: TeamCreateOneWithoutMatchingDoneListInput
  status: Status!
  stadium: String!
  address: String
  area: Area!
  date: String!
  startTime: String!
  endTime: String!
  description: String
  result: Result
  appliedLists: ApplyCreateManyWithoutMatchInput
}

type MatchEdge {
  node: Match!
  cursor: String!
}

enum MatchOrderByInput {
  seq_ASC
  seq_DESC
  status_ASC
  status_DESC
  stadium_ASC
  stadium_DESC
  address_ASC
  address_DESC
  area_ASC
  area_DESC
  date_ASC
  date_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
  description_ASC
  description_DESC
  result_ASC
  result_DESC
}

type MatchPreviousValues {
  seq: Int!
  status: Status!
  stadium: String!
  address: String
  area: Area!
  date: String!
  startTime: String!
  endTime: String!
  description: String
  result: Result
}

input MatchScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  stadium: String
  stadium_not: String
  stadium_in: [String!]
  stadium_not_in: [String!]
  stadium_lt: String
  stadium_lte: String
  stadium_gt: String
  stadium_gte: String
  stadium_contains: String
  stadium_not_contains: String
  stadium_starts_with: String
  stadium_not_starts_with: String
  stadium_ends_with: String
  stadium_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  area: Area
  area_not: Area
  area_in: [Area!]
  area_not_in: [Area!]
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  AND: [MatchScalarWhereInput!]
  OR: [MatchScalarWhereInput!]
  NOT: [MatchScalarWhereInput!]
}

type MatchSubscriptionPayload {
  mutation: MutationType!
  node: Match
  updatedFields: [String!]
  previousValues: MatchPreviousValues
}

input MatchSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatchWhereInput
  AND: [MatchSubscriptionWhereInput!]
  OR: [MatchSubscriptionWhereInput!]
  NOT: [MatchSubscriptionWhereInput!]
}

input MatchUpdateInput {
  author: PlayerUpdateOneRequiredWithoutUploadMatchListInput
  host: TeamUpdateOneRequiredWithoutUploadMatchListInput
  guest: TeamUpdateOneWithoutMatchingDoneListInput
  status: Status
  stadium: String
  address: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyUpdateManyWithoutMatchInput
}

input MatchUpdateManyDataInput {
  status: Status
  stadium: String
  address: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateManyMutationInput {
  status: Status
  stadium: String
  address: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateManyWithoutAuthorInput {
  create: [MatchCreateWithoutAuthorInput!]
  delete: [MatchWhereUniqueInput!]
  connect: [MatchWhereUniqueInput!]
  set: [MatchWhereUniqueInput!]
  disconnect: [MatchWhereUniqueInput!]
  update: [MatchUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [MatchUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [MatchScalarWhereInput!]
  updateMany: [MatchUpdateManyWithWhereNestedInput!]
}

input MatchUpdateManyWithoutGuestInput {
  create: [MatchCreateWithoutGuestInput!]
  delete: [MatchWhereUniqueInput!]
  connect: [MatchWhereUniqueInput!]
  set: [MatchWhereUniqueInput!]
  disconnect: [MatchWhereUniqueInput!]
  update: [MatchUpdateWithWhereUniqueWithoutGuestInput!]
  upsert: [MatchUpsertWithWhereUniqueWithoutGuestInput!]
  deleteMany: [MatchScalarWhereInput!]
  updateMany: [MatchUpdateManyWithWhereNestedInput!]
}

input MatchUpdateManyWithoutHostInput {
  create: [MatchCreateWithoutHostInput!]
  delete: [MatchWhereUniqueInput!]
  connect: [MatchWhereUniqueInput!]
  set: [MatchWhereUniqueInput!]
  disconnect: [MatchWhereUniqueInput!]
  update: [MatchUpdateWithWhereUniqueWithoutHostInput!]
  upsert: [MatchUpsertWithWhereUniqueWithoutHostInput!]
  deleteMany: [MatchScalarWhereInput!]
  updateMany: [MatchUpdateManyWithWhereNestedInput!]
}

input MatchUpdateManyWithWhereNestedInput {
  where: MatchScalarWhereInput!
  data: MatchUpdateManyDataInput!
}

input MatchUpdateOneWithoutAppliedListsInput {
  create: MatchCreateWithoutAppliedListsInput
  update: MatchUpdateWithoutAppliedListsDataInput
  upsert: MatchUpsertWithoutAppliedListsInput
  delete: Boolean
  disconnect: Boolean
  connect: MatchWhereUniqueInput
}

input MatchUpdateWithoutAppliedListsDataInput {
  author: PlayerUpdateOneRequiredWithoutUploadMatchListInput
  host: TeamUpdateOneRequiredWithoutUploadMatchListInput
  guest: TeamUpdateOneWithoutMatchingDoneListInput
  status: Status
  stadium: String
  address: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateWithoutAuthorDataInput {
  host: TeamUpdateOneRequiredWithoutUploadMatchListInput
  guest: TeamUpdateOneWithoutMatchingDoneListInput
  status: Status
  stadium: String
  address: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyUpdateManyWithoutMatchInput
}

input MatchUpdateWithoutGuestDataInput {
  author: PlayerUpdateOneRequiredWithoutUploadMatchListInput
  host: TeamUpdateOneRequiredWithoutUploadMatchListInput
  status: Status
  stadium: String
  address: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyUpdateManyWithoutMatchInput
}

input MatchUpdateWithoutHostDataInput {
  author: PlayerUpdateOneRequiredWithoutUploadMatchListInput
  guest: TeamUpdateOneWithoutMatchingDoneListInput
  status: Status
  stadium: String
  address: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyUpdateManyWithoutMatchInput
}

input MatchUpdateWithWhereUniqueWithoutAuthorInput {
  where: MatchWhereUniqueInput!
  data: MatchUpdateWithoutAuthorDataInput!
}

input MatchUpdateWithWhereUniqueWithoutGuestInput {
  where: MatchWhereUniqueInput!
  data: MatchUpdateWithoutGuestDataInput!
}

input MatchUpdateWithWhereUniqueWithoutHostInput {
  where: MatchWhereUniqueInput!
  data: MatchUpdateWithoutHostDataInput!
}

input MatchUpsertWithoutAppliedListsInput {
  update: MatchUpdateWithoutAppliedListsDataInput!
  create: MatchCreateWithoutAppliedListsInput!
}

input MatchUpsertWithWhereUniqueWithoutAuthorInput {
  where: MatchWhereUniqueInput!
  update: MatchUpdateWithoutAuthorDataInput!
  create: MatchCreateWithoutAuthorInput!
}

input MatchUpsertWithWhereUniqueWithoutGuestInput {
  where: MatchWhereUniqueInput!
  update: MatchUpdateWithoutGuestDataInput!
  create: MatchCreateWithoutGuestInput!
}

input MatchUpsertWithWhereUniqueWithoutHostInput {
  where: MatchWhereUniqueInput!
  update: MatchUpdateWithoutHostDataInput!
  create: MatchCreateWithoutHostInput!
}

input MatchWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  author: PlayerWhereInput
  host: TeamWhereInput
  guest: TeamWhereInput
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  stadium: String
  stadium_not: String
  stadium_in: [String!]
  stadium_not_in: [String!]
  stadium_lt: String
  stadium_lte: String
  stadium_gt: String
  stadium_gte: String
  stadium_contains: String
  stadium_not_contains: String
  stadium_starts_with: String
  stadium_not_starts_with: String
  stadium_ends_with: String
  stadium_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  area: Area
  area_not: Area
  area_in: [Area!]
  area_not_in: [Area!]
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  appliedLists_every: ApplyWhereInput
  appliedLists_some: ApplyWhereInput
  appliedLists_none: ApplyWhereInput
  AND: [MatchWhereInput!]
  OR: [MatchWhereInput!]
  NOT: [MatchWhereInput!]
}

input MatchWhereUniqueInput {
  seq: Int
}

type Mutation {
  createApply(data: ApplyCreateInput!): Apply!
  updateApply(data: ApplyUpdateInput!, where: ApplyWhereUniqueInput!): Apply
  upsertApply(where: ApplyWhereUniqueInput!, create: ApplyCreateInput!, update: ApplyUpdateInput!): Apply!
  deleteApply(where: ApplyWhereUniqueInput!): Apply
  deleteManyApplies(where: ApplyWhereInput): BatchPayload!
  createMatch(data: MatchCreateInput!): Match!
  updateMatch(data: MatchUpdateInput!, where: MatchWhereUniqueInput!): Match
  updateManyMatches(data: MatchUpdateManyMutationInput!, where: MatchWhereInput): BatchPayload!
  upsertMatch(where: MatchWhereUniqueInput!, create: MatchCreateInput!, update: MatchUpdateInput!): Match!
  deleteMatch(where: MatchWhereUniqueInput!): Match
  deleteManyMatches(where: MatchWhereInput): BatchPayload!
  createNotifier(data: NotifierCreateInput!): Notifier!
  updateNotifier(data: NotifierUpdateInput!, where: NotifierWhereUniqueInput!): Notifier
  updateManyNotifiers(data: NotifierUpdateManyMutationInput!, where: NotifierWhereInput): BatchPayload!
  upsertNotifier(where: NotifierWhereUniqueInput!, create: NotifierCreateInput!, update: NotifierUpdateInput!): Notifier!
  deleteNotifier(where: NotifierWhereUniqueInput!): Notifier
  deleteManyNotifiers(where: NotifierWhereInput): BatchPayload!
  createPlayer(data: PlayerCreateInput!): Player!
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  updateManyPlayers(data: PlayerUpdateManyMutationInput!, where: PlayerWhereInput): BatchPayload!
  upsertPlayer(where: PlayerWhereUniqueInput!, create: PlayerCreateInput!, update: PlayerUpdateInput!): Player!
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  createStadium(data: StadiumCreateInput!): Stadium!
  updateStadium(data: StadiumUpdateInput!, where: StadiumWhereUniqueInput!): Stadium
  updateManyStadiums(data: StadiumUpdateManyMutationInput!, where: StadiumWhereInput): BatchPayload!
  upsertStadium(where: StadiumWhereUniqueInput!, create: StadiumCreateInput!, update: StadiumUpdateInput!): Stadium!
  deleteStadium(where: StadiumWhereUniqueInput!): Stadium
  deleteManyStadiums(where: StadiumWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Notifier {
  seq: Int!
  player: Player!
  area: [Area!]!
  date: String
  startTime: String
  endTime: String
}

type NotifierConnection {
  pageInfo: PageInfo!
  edges: [NotifierEdge]!
  aggregate: AggregateNotifier!
}

input NotifierCreateareaInput {
  set: [Area!]
}

input NotifierCreateInput {
  seq: Int
  player: PlayerCreateOneWithoutNotiListInput!
  area: NotifierCreateareaInput
  date: String
  startTime: String
  endTime: String
}

input NotifierCreateManyWithoutPlayerInput {
  create: [NotifierCreateWithoutPlayerInput!]
  connect: [NotifierWhereUniqueInput!]
}

input NotifierCreateWithoutPlayerInput {
  seq: Int
  area: NotifierCreateareaInput
  date: String
  startTime: String
  endTime: String
}

type NotifierEdge {
  node: Notifier!
  cursor: String!
}

enum NotifierOrderByInput {
  seq_ASC
  seq_DESC
  date_ASC
  date_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
}

type NotifierPreviousValues {
  seq: Int!
  area: [Area!]!
  date: String
  startTime: String
  endTime: String
}

input NotifierScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  AND: [NotifierScalarWhereInput!]
  OR: [NotifierScalarWhereInput!]
  NOT: [NotifierScalarWhereInput!]
}

type NotifierSubscriptionPayload {
  mutation: MutationType!
  node: Notifier
  updatedFields: [String!]
  previousValues: NotifierPreviousValues
}

input NotifierSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotifierWhereInput
  AND: [NotifierSubscriptionWhereInput!]
  OR: [NotifierSubscriptionWhereInput!]
  NOT: [NotifierSubscriptionWhereInput!]
}

input NotifierUpdateareaInput {
  set: [Area!]
}

input NotifierUpdateInput {
  player: PlayerUpdateOneRequiredWithoutNotiListInput
  area: NotifierUpdateareaInput
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateManyDataInput {
  area: NotifierUpdateareaInput
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateManyMutationInput {
  area: NotifierUpdateareaInput
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateManyWithoutPlayerInput {
  create: [NotifierCreateWithoutPlayerInput!]
  delete: [NotifierWhereUniqueInput!]
  connect: [NotifierWhereUniqueInput!]
  set: [NotifierWhereUniqueInput!]
  disconnect: [NotifierWhereUniqueInput!]
  update: [NotifierUpdateWithWhereUniqueWithoutPlayerInput!]
  upsert: [NotifierUpsertWithWhereUniqueWithoutPlayerInput!]
  deleteMany: [NotifierScalarWhereInput!]
  updateMany: [NotifierUpdateManyWithWhereNestedInput!]
}

input NotifierUpdateManyWithWhereNestedInput {
  where: NotifierScalarWhereInput!
  data: NotifierUpdateManyDataInput!
}

input NotifierUpdateWithoutPlayerDataInput {
  area: NotifierUpdateareaInput
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateWithWhereUniqueWithoutPlayerInput {
  where: NotifierWhereUniqueInput!
  data: NotifierUpdateWithoutPlayerDataInput!
}

input NotifierUpsertWithWhereUniqueWithoutPlayerInput {
  where: NotifierWhereUniqueInput!
  update: NotifierUpdateWithoutPlayerDataInput!
  create: NotifierCreateWithoutPlayerInput!
}

input NotifierWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  player: PlayerWhereInput
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  AND: [NotifierWhereInput!]
  OR: [NotifierWhereInput!]
  NOT: [NotifierWhereInput!]
}

input NotifierWhereUniqueInput {
  seq: Int
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  seq: Int!
  playerId: String!
  team: Team
  name: String
  phone: String
  email: String
  authProvider: Auth!
  notiList(where: NotifierWhereInput, orderBy: NotifierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notifier!]
  uploadMatchList(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match!]
  teamCreate(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team!]
  applyingList(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Apply!]
}

type PlayerConnection {
  pageInfo: PageInfo!
  edges: [PlayerEdge]!
  aggregate: AggregatePlayer!
}

input PlayerCreateInput {
  seq: Int
  playerId: String!
  team: TeamCreateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth!
  notiList: NotifierCreateManyWithoutPlayerInput
  uploadMatchList: MatchCreateManyWithoutAuthorInput
  teamCreate: TeamCreateManyWithoutOwnerInput
  applyingList: ApplyCreateManyWithoutPlayerInput
}

input PlayerCreateManyWithoutTeamInput {
  create: [PlayerCreateWithoutTeamInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateOneWithoutApplyingListInput {
  create: PlayerCreateWithoutApplyingListInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateOneWithoutNotiListInput {
  create: PlayerCreateWithoutNotiListInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateOneWithoutTeamCreateInput {
  create: PlayerCreateWithoutTeamCreateInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateOneWithoutUploadMatchListInput {
  create: PlayerCreateWithoutUploadMatchListInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateWithoutApplyingListInput {
  seq: Int
  playerId: String!
  team: TeamCreateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth!
  notiList: NotifierCreateManyWithoutPlayerInput
  uploadMatchList: MatchCreateManyWithoutAuthorInput
  teamCreate: TeamCreateManyWithoutOwnerInput
}

input PlayerCreateWithoutNotiListInput {
  seq: Int
  playerId: String!
  team: TeamCreateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth!
  uploadMatchList: MatchCreateManyWithoutAuthorInput
  teamCreate: TeamCreateManyWithoutOwnerInput
  applyingList: ApplyCreateManyWithoutPlayerInput
}

input PlayerCreateWithoutTeamCreateInput {
  seq: Int
  playerId: String!
  team: TeamCreateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth!
  notiList: NotifierCreateManyWithoutPlayerInput
  uploadMatchList: MatchCreateManyWithoutAuthorInput
  applyingList: ApplyCreateManyWithoutPlayerInput
}

input PlayerCreateWithoutTeamInput {
  seq: Int
  playerId: String!
  name: String
  phone: String
  email: String
  authProvider: Auth!
  notiList: NotifierCreateManyWithoutPlayerInput
  uploadMatchList: MatchCreateManyWithoutAuthorInput
  teamCreate: TeamCreateManyWithoutOwnerInput
  applyingList: ApplyCreateManyWithoutPlayerInput
}

input PlayerCreateWithoutUploadMatchListInput {
  seq: Int
  playerId: String!
  team: TeamCreateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth!
  notiList: NotifierCreateManyWithoutPlayerInput
  teamCreate: TeamCreateManyWithoutOwnerInput
  applyingList: ApplyCreateManyWithoutPlayerInput
}

type PlayerEdge {
  node: Player!
  cursor: String!
}

enum PlayerOrderByInput {
  seq_ASC
  seq_DESC
  playerId_ASC
  playerId_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
  email_ASC
  email_DESC
  authProvider_ASC
  authProvider_DESC
}

type PlayerPreviousValues {
  seq: Int!
  playerId: String!
  name: String
  phone: String
  email: String
  authProvider: Auth!
}

input PlayerScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  playerId: String
  playerId_not: String
  playerId_in: [String!]
  playerId_not_in: [String!]
  playerId_lt: String
  playerId_lte: String
  playerId_gt: String
  playerId_gte: String
  playerId_contains: String
  playerId_not_contains: String
  playerId_starts_with: String
  playerId_not_starts_with: String
  playerId_ends_with: String
  playerId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  authProvider: Auth
  authProvider_not: Auth
  authProvider_in: [Auth!]
  authProvider_not_in: [Auth!]
  AND: [PlayerScalarWhereInput!]
  OR: [PlayerScalarWhereInput!]
  NOT: [PlayerScalarWhereInput!]
}

type PlayerSubscriptionPayload {
  mutation: MutationType!
  node: Player
  updatedFields: [String!]
  previousValues: PlayerPreviousValues
}

input PlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerWhereInput
  AND: [PlayerSubscriptionWhereInput!]
  OR: [PlayerSubscriptionWhereInput!]
  NOT: [PlayerSubscriptionWhereInput!]
}

input PlayerUpdateInput {
  playerId: String
  team: TeamUpdateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth
  notiList: NotifierUpdateManyWithoutPlayerInput
  uploadMatchList: MatchUpdateManyWithoutAuthorInput
  teamCreate: TeamUpdateManyWithoutOwnerInput
  applyingList: ApplyUpdateManyWithoutPlayerInput
}

input PlayerUpdateManyDataInput {
  playerId: String
  name: String
  phone: String
  email: String
  authProvider: Auth
}

input PlayerUpdateManyMutationInput {
  playerId: String
  name: String
  phone: String
  email: String
  authProvider: Auth
}

input PlayerUpdateManyWithoutTeamInput {
  create: [PlayerCreateWithoutTeamInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput!
  data: PlayerUpdateManyDataInput!
}

input PlayerUpdateOneRequiredWithoutNotiListInput {
  create: PlayerCreateWithoutNotiListInput
  update: PlayerUpdateWithoutNotiListDataInput
  upsert: PlayerUpsertWithoutNotiListInput
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateOneRequiredWithoutUploadMatchListInput {
  create: PlayerCreateWithoutUploadMatchListInput
  update: PlayerUpdateWithoutUploadMatchListDataInput
  upsert: PlayerUpsertWithoutUploadMatchListInput
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateOneWithoutApplyingListInput {
  create: PlayerCreateWithoutApplyingListInput
  update: PlayerUpdateWithoutApplyingListDataInput
  upsert: PlayerUpsertWithoutApplyingListInput
  delete: Boolean
  disconnect: Boolean
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateOneWithoutTeamCreateInput {
  create: PlayerCreateWithoutTeamCreateInput
  update: PlayerUpdateWithoutTeamCreateDataInput
  upsert: PlayerUpsertWithoutTeamCreateInput
  delete: Boolean
  disconnect: Boolean
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateWithoutApplyingListDataInput {
  playerId: String
  team: TeamUpdateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth
  notiList: NotifierUpdateManyWithoutPlayerInput
  uploadMatchList: MatchUpdateManyWithoutAuthorInput
  teamCreate: TeamUpdateManyWithoutOwnerInput
}

input PlayerUpdateWithoutNotiListDataInput {
  playerId: String
  team: TeamUpdateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth
  uploadMatchList: MatchUpdateManyWithoutAuthorInput
  teamCreate: TeamUpdateManyWithoutOwnerInput
  applyingList: ApplyUpdateManyWithoutPlayerInput
}

input PlayerUpdateWithoutTeamCreateDataInput {
  playerId: String
  team: TeamUpdateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth
  notiList: NotifierUpdateManyWithoutPlayerInput
  uploadMatchList: MatchUpdateManyWithoutAuthorInput
  applyingList: ApplyUpdateManyWithoutPlayerInput
}

input PlayerUpdateWithoutTeamDataInput {
  playerId: String
  name: String
  phone: String
  email: String
  authProvider: Auth
  notiList: NotifierUpdateManyWithoutPlayerInput
  uploadMatchList: MatchUpdateManyWithoutAuthorInput
  teamCreate: TeamUpdateManyWithoutOwnerInput
  applyingList: ApplyUpdateManyWithoutPlayerInput
}

input PlayerUpdateWithoutUploadMatchListDataInput {
  playerId: String
  team: TeamUpdateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  authProvider: Auth
  notiList: NotifierUpdateManyWithoutPlayerInput
  teamCreate: TeamUpdateManyWithoutOwnerInput
  applyingList: ApplyUpdateManyWithoutPlayerInput
}

input PlayerUpdateWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutTeamDataInput!
}

input PlayerUpsertWithoutApplyingListInput {
  update: PlayerUpdateWithoutApplyingListDataInput!
  create: PlayerCreateWithoutApplyingListInput!
}

input PlayerUpsertWithoutNotiListInput {
  update: PlayerUpdateWithoutNotiListDataInput!
  create: PlayerCreateWithoutNotiListInput!
}

input PlayerUpsertWithoutTeamCreateInput {
  update: PlayerUpdateWithoutTeamCreateDataInput!
  create: PlayerCreateWithoutTeamCreateInput!
}

input PlayerUpsertWithoutUploadMatchListInput {
  update: PlayerUpdateWithoutUploadMatchListDataInput!
  create: PlayerCreateWithoutUploadMatchListInput!
}

input PlayerUpsertWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutTeamDataInput!
  create: PlayerCreateWithoutTeamInput!
}

input PlayerWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  playerId: String
  playerId_not: String
  playerId_in: [String!]
  playerId_not_in: [String!]
  playerId_lt: String
  playerId_lte: String
  playerId_gt: String
  playerId_gte: String
  playerId_contains: String
  playerId_not_contains: String
  playerId_starts_with: String
  playerId_not_starts_with: String
  playerId_ends_with: String
  playerId_not_ends_with: String
  team: TeamWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  authProvider: Auth
  authProvider_not: Auth
  authProvider_in: [Auth!]
  authProvider_not_in: [Auth!]
  notiList_every: NotifierWhereInput
  notiList_some: NotifierWhereInput
  notiList_none: NotifierWhereInput
  uploadMatchList_every: MatchWhereInput
  uploadMatchList_some: MatchWhereInput
  uploadMatchList_none: MatchWhereInput
  teamCreate_every: TeamWhereInput
  teamCreate_some: TeamWhereInput
  teamCreate_none: TeamWhereInput
  applyingList_every: ApplyWhereInput
  applyingList_some: ApplyWhereInput
  applyingList_none: ApplyWhereInput
  AND: [PlayerWhereInput!]
  OR: [PlayerWhereInput!]
  NOT: [PlayerWhereInput!]
}

input PlayerWhereUniqueInput {
  seq: Int
  playerId: String
}

type Query {
  apply(where: ApplyWhereUniqueInput!): Apply
  applies(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Apply]!
  appliesConnection(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ApplyConnection!
  match(where: MatchWhereUniqueInput!): Match
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match]!
  matchesConnection(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatchConnection!
  notifier(where: NotifierWhereUniqueInput!): Notifier
  notifiers(where: NotifierWhereInput, orderBy: NotifierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notifier]!
  notifiersConnection(where: NotifierWhereInput, orderBy: NotifierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotifierConnection!
  player(where: PlayerWhereUniqueInput!): Player
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player]!
  playersConnection(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerConnection!
  stadium(where: StadiumWhereUniqueInput!): Stadium
  stadiums(where: StadiumWhereInput, orderBy: StadiumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stadium]!
  stadiumsConnection(where: StadiumWhereInput, orderBy: StadiumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StadiumConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  node(id: ID!): Node
}

enum Result {
  HOST
  GUEST
  DRAW
}

type Stadium {
  seq: Int!
  name: String
  address: String
}

type StadiumConnection {
  pageInfo: PageInfo!
  edges: [StadiumEdge]!
  aggregate: AggregateStadium!
}

input StadiumCreateInput {
  seq: Int
  name: String
  address: String
}

type StadiumEdge {
  node: Stadium!
  cursor: String!
}

enum StadiumOrderByInput {
  seq_ASC
  seq_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
}

type StadiumPreviousValues {
  seq: Int!
  name: String
  address: String
}

type StadiumSubscriptionPayload {
  mutation: MutationType!
  node: Stadium
  updatedFields: [String!]
  previousValues: StadiumPreviousValues
}

input StadiumSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StadiumWhereInput
  AND: [StadiumSubscriptionWhereInput!]
  OR: [StadiumSubscriptionWhereInput!]
  NOT: [StadiumSubscriptionWhereInput!]
}

input StadiumUpdateInput {
  name: String
  address: String
}

input StadiumUpdateManyMutationInput {
  name: String
  address: String
}

input StadiumWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [StadiumWhereInput!]
  OR: [StadiumWhereInput!]
  NOT: [StadiumWhereInput!]
}

input StadiumWhereUniqueInput {
  seq: Int
}

enum Status {
  OPEN
  CLOSED
}

type Subscription {
  apply(where: ApplySubscriptionWhereInput): ApplySubscriptionPayload
  match(where: MatchSubscriptionWhereInput): MatchSubscriptionPayload
  notifier(where: NotifierSubscriptionWhereInput): NotifierSubscriptionPayload
  player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
  stadium(where: StadiumSubscriptionWhereInput): StadiumSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
}

type Team {
  seq: Int!
  name: String!
  logo: String
  homeArea: Area
  introduction: String
  win: Int!
  draw: Int!
  lose: Int!
  rating: Int!
  teamUniqueId: String!
  owner: Player
  members(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
  uploadMatchList(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match!]
  matchingDoneList(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match!]
  onApplyingList(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Apply!]
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  seq: Int
  name: String!
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String!
  owner: PlayerCreateOneWithoutTeamCreateInput
  members: PlayerCreateManyWithoutTeamInput
  uploadMatchList: MatchCreateManyWithoutHostInput
  matchingDoneList: MatchCreateManyWithoutGuestInput
  onApplyingList: ApplyCreateManyWithoutTeamInput
}

input TeamCreateManyWithoutOwnerInput {
  create: [TeamCreateWithoutOwnerInput!]
  connect: [TeamWhereUniqueInput!]
}

input TeamCreateOneWithoutMatchingDoneListInput {
  create: TeamCreateWithoutMatchingDoneListInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutMembersInput {
  create: TeamCreateWithoutMembersInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutOnApplyingListInput {
  create: TeamCreateWithoutOnApplyingListInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutUploadMatchListInput {
  create: TeamCreateWithoutUploadMatchListInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutMatchingDoneListInput {
  seq: Int
  name: String!
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String!
  owner: PlayerCreateOneWithoutTeamCreateInput
  members: PlayerCreateManyWithoutTeamInput
  uploadMatchList: MatchCreateManyWithoutHostInput
  onApplyingList: ApplyCreateManyWithoutTeamInput
}

input TeamCreateWithoutMembersInput {
  seq: Int
  name: String!
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String!
  owner: PlayerCreateOneWithoutTeamCreateInput
  uploadMatchList: MatchCreateManyWithoutHostInput
  matchingDoneList: MatchCreateManyWithoutGuestInput
  onApplyingList: ApplyCreateManyWithoutTeamInput
}

input TeamCreateWithoutOnApplyingListInput {
  seq: Int
  name: String!
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String!
  owner: PlayerCreateOneWithoutTeamCreateInput
  members: PlayerCreateManyWithoutTeamInput
  uploadMatchList: MatchCreateManyWithoutHostInput
  matchingDoneList: MatchCreateManyWithoutGuestInput
}

input TeamCreateWithoutOwnerInput {
  seq: Int
  name: String!
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String!
  members: PlayerCreateManyWithoutTeamInput
  uploadMatchList: MatchCreateManyWithoutHostInput
  matchingDoneList: MatchCreateManyWithoutGuestInput
  onApplyingList: ApplyCreateManyWithoutTeamInput
}

input TeamCreateWithoutUploadMatchListInput {
  seq: Int
  name: String!
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String!
  owner: PlayerCreateOneWithoutTeamCreateInput
  members: PlayerCreateManyWithoutTeamInput
  matchingDoneList: MatchCreateManyWithoutGuestInput
  onApplyingList: ApplyCreateManyWithoutTeamInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  seq_ASC
  seq_DESC
  name_ASC
  name_DESC
  logo_ASC
  logo_DESC
  homeArea_ASC
  homeArea_DESC
  introduction_ASC
  introduction_DESC
  win_ASC
  win_DESC
  draw_ASC
  draw_DESC
  lose_ASC
  lose_DESC
  rating_ASC
  rating_DESC
  teamUniqueId_ASC
  teamUniqueId_DESC
}

type TeamPreviousValues {
  seq: Int!
  name: String!
  logo: String
  homeArea: Area
  introduction: String
  win: Int!
  draw: Int!
  lose: Int!
  rating: Int!
  teamUniqueId: String!
}

input TeamScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  logo: String
  logo_not: String
  logo_in: [String!]
  logo_not_in: [String!]
  logo_lt: String
  logo_lte: String
  logo_gt: String
  logo_gte: String
  logo_contains: String
  logo_not_contains: String
  logo_starts_with: String
  logo_not_starts_with: String
  logo_ends_with: String
  logo_not_ends_with: String
  homeArea: Area
  homeArea_not: Area
  homeArea_in: [Area!]
  homeArea_not_in: [Area!]
  introduction: String
  introduction_not: String
  introduction_in: [String!]
  introduction_not_in: [String!]
  introduction_lt: String
  introduction_lte: String
  introduction_gt: String
  introduction_gte: String
  introduction_contains: String
  introduction_not_contains: String
  introduction_starts_with: String
  introduction_not_starts_with: String
  introduction_ends_with: String
  introduction_not_ends_with: String
  win: Int
  win_not: Int
  win_in: [Int!]
  win_not_in: [Int!]
  win_lt: Int
  win_lte: Int
  win_gt: Int
  win_gte: Int
  draw: Int
  draw_not: Int
  draw_in: [Int!]
  draw_not_in: [Int!]
  draw_lt: Int
  draw_lte: Int
  draw_gt: Int
  draw_gte: Int
  lose: Int
  lose_not: Int
  lose_in: [Int!]
  lose_not_in: [Int!]
  lose_lt: Int
  lose_lte: Int
  lose_gt: Int
  lose_gte: Int
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  teamUniqueId: String
  teamUniqueId_not: String
  teamUniqueId_in: [String!]
  teamUniqueId_not_in: [String!]
  teamUniqueId_lt: String
  teamUniqueId_lte: String
  teamUniqueId_gt: String
  teamUniqueId_gte: String
  teamUniqueId_contains: String
  teamUniqueId_not_contains: String
  teamUniqueId_starts_with: String
  teamUniqueId_not_starts_with: String
  teamUniqueId_ends_with: String
  teamUniqueId_not_ends_with: String
  AND: [TeamScalarWhereInput!]
  OR: [TeamScalarWhereInput!]
  NOT: [TeamScalarWhereInput!]
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateInput {
  name: String
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String
  owner: PlayerUpdateOneWithoutTeamCreateInput
  members: PlayerUpdateManyWithoutTeamInput
  uploadMatchList: MatchUpdateManyWithoutHostInput
  matchingDoneList: MatchUpdateManyWithoutGuestInput
  onApplyingList: ApplyUpdateManyWithoutTeamInput
}

input TeamUpdateManyDataInput {
  name: String
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String
}

input TeamUpdateManyMutationInput {
  name: String
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String
}

input TeamUpdateManyWithoutOwnerInput {
  create: [TeamCreateWithoutOwnerInput!]
  delete: [TeamWhereUniqueInput!]
  connect: [TeamWhereUniqueInput!]
  set: [TeamWhereUniqueInput!]
  disconnect: [TeamWhereUniqueInput!]
  update: [TeamUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [TeamUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [TeamScalarWhereInput!]
  updateMany: [TeamUpdateManyWithWhereNestedInput!]
}

input TeamUpdateManyWithWhereNestedInput {
  where: TeamScalarWhereInput!
  data: TeamUpdateManyDataInput!
}

input TeamUpdateOneRequiredWithoutUploadMatchListInput {
  create: TeamCreateWithoutUploadMatchListInput
  update: TeamUpdateWithoutUploadMatchListDataInput
  upsert: TeamUpsertWithoutUploadMatchListInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutMatchingDoneListInput {
  create: TeamCreateWithoutMatchingDoneListInput
  update: TeamUpdateWithoutMatchingDoneListDataInput
  upsert: TeamUpsertWithoutMatchingDoneListInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutMembersInput {
  create: TeamCreateWithoutMembersInput
  update: TeamUpdateWithoutMembersDataInput
  upsert: TeamUpsertWithoutMembersInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutOnApplyingListInput {
  create: TeamCreateWithoutOnApplyingListInput
  update: TeamUpdateWithoutOnApplyingListDataInput
  upsert: TeamUpsertWithoutOnApplyingListInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutMatchingDoneListDataInput {
  name: String
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String
  owner: PlayerUpdateOneWithoutTeamCreateInput
  members: PlayerUpdateManyWithoutTeamInput
  uploadMatchList: MatchUpdateManyWithoutHostInput
  onApplyingList: ApplyUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutMembersDataInput {
  name: String
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String
  owner: PlayerUpdateOneWithoutTeamCreateInput
  uploadMatchList: MatchUpdateManyWithoutHostInput
  matchingDoneList: MatchUpdateManyWithoutGuestInput
  onApplyingList: ApplyUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutOnApplyingListDataInput {
  name: String
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String
  owner: PlayerUpdateOneWithoutTeamCreateInput
  members: PlayerUpdateManyWithoutTeamInput
  uploadMatchList: MatchUpdateManyWithoutHostInput
  matchingDoneList: MatchUpdateManyWithoutGuestInput
}

input TeamUpdateWithoutOwnerDataInput {
  name: String
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String
  members: PlayerUpdateManyWithoutTeamInput
  uploadMatchList: MatchUpdateManyWithoutHostInput
  matchingDoneList: MatchUpdateManyWithoutGuestInput
  onApplyingList: ApplyUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutUploadMatchListDataInput {
  name: String
  logo: String
  homeArea: Area
  introduction: String
  win: Int
  draw: Int
  lose: Int
  rating: Int
  teamUniqueId: String
  owner: PlayerUpdateOneWithoutTeamCreateInput
  members: PlayerUpdateManyWithoutTeamInput
  matchingDoneList: MatchUpdateManyWithoutGuestInput
  onApplyingList: ApplyUpdateManyWithoutTeamInput
}

input TeamUpdateWithWhereUniqueWithoutOwnerInput {
  where: TeamWhereUniqueInput!
  data: TeamUpdateWithoutOwnerDataInput!
}

input TeamUpsertWithoutMatchingDoneListInput {
  update: TeamUpdateWithoutMatchingDoneListDataInput!
  create: TeamCreateWithoutMatchingDoneListInput!
}

input TeamUpsertWithoutMembersInput {
  update: TeamUpdateWithoutMembersDataInput!
  create: TeamCreateWithoutMembersInput!
}

input TeamUpsertWithoutOnApplyingListInput {
  update: TeamUpdateWithoutOnApplyingListDataInput!
  create: TeamCreateWithoutOnApplyingListInput!
}

input TeamUpsertWithoutUploadMatchListInput {
  update: TeamUpdateWithoutUploadMatchListDataInput!
  create: TeamCreateWithoutUploadMatchListInput!
}

input TeamUpsertWithWhereUniqueWithoutOwnerInput {
  where: TeamWhereUniqueInput!
  update: TeamUpdateWithoutOwnerDataInput!
  create: TeamCreateWithoutOwnerInput!
}

input TeamWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  logo: String
  logo_not: String
  logo_in: [String!]
  logo_not_in: [String!]
  logo_lt: String
  logo_lte: String
  logo_gt: String
  logo_gte: String
  logo_contains: String
  logo_not_contains: String
  logo_starts_with: String
  logo_not_starts_with: String
  logo_ends_with: String
  logo_not_ends_with: String
  homeArea: Area
  homeArea_not: Area
  homeArea_in: [Area!]
  homeArea_not_in: [Area!]
  introduction: String
  introduction_not: String
  introduction_in: [String!]
  introduction_not_in: [String!]
  introduction_lt: String
  introduction_lte: String
  introduction_gt: String
  introduction_gte: String
  introduction_contains: String
  introduction_not_contains: String
  introduction_starts_with: String
  introduction_not_starts_with: String
  introduction_ends_with: String
  introduction_not_ends_with: String
  win: Int
  win_not: Int
  win_in: [Int!]
  win_not_in: [Int!]
  win_lt: Int
  win_lte: Int
  win_gt: Int
  win_gte: Int
  draw: Int
  draw_not: Int
  draw_in: [Int!]
  draw_not_in: [Int!]
  draw_lt: Int
  draw_lte: Int
  draw_gt: Int
  draw_gte: Int
  lose: Int
  lose_not: Int
  lose_in: [Int!]
  lose_not_in: [Int!]
  lose_lt: Int
  lose_lte: Int
  lose_gt: Int
  lose_gte: Int
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  teamUniqueId: String
  teamUniqueId_not: String
  teamUniqueId_in: [String!]
  teamUniqueId_not_in: [String!]
  teamUniqueId_lt: String
  teamUniqueId_lte: String
  teamUniqueId_gt: String
  teamUniqueId_gte: String
  teamUniqueId_contains: String
  teamUniqueId_not_contains: String
  teamUniqueId_starts_with: String
  teamUniqueId_not_starts_with: String
  teamUniqueId_ends_with: String
  teamUniqueId_not_ends_with: String
  owner: PlayerWhereInput
  members_every: PlayerWhereInput
  members_some: PlayerWhereInput
  members_none: PlayerWhereInput
  uploadMatchList_every: MatchWhereInput
  uploadMatchList_some: MatchWhereInput
  uploadMatchList_none: MatchWhereInput
  matchingDoneList_every: MatchWhereInput
  matchingDoneList_some: MatchWhereInput
  matchingDoneList_none: MatchWhereInput
  onApplyingList_every: ApplyWhereInput
  onApplyingList_some: ApplyWhereInput
  onApplyingList_none: ApplyWhereInput
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  seq: Int
  teamUniqueId: String
}
`
      }
    