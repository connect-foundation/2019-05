module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateApply {
  count: Int!
}

type AggregateMatch {
  count: Int!
}

type AggregateNotifier {
  count: Int!
}

type AggregatePlayer {
  count: Int!
}

type AggregateStadium {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type Apply {
  seq: Int!
  team: Team
  match: Match
}

type ApplyConnection {
  pageInfo: PageInfo!
  edges: [ApplyEdge]!
  aggregate: AggregateApply!
}

input ApplyCreateInput {
  seq: Int
  team: TeamCreateOneInput
  match: MatchCreateOneInput
}

type ApplyEdge {
  node: Apply!
  cursor: String!
}

enum ApplyOrderByInput {
  seq_ASC
  seq_DESC
}

type ApplyPreviousValues {
  seq: Int!
}

type ApplySubscriptionPayload {
  mutation: MutationType!
  node: Apply
  updatedFields: [String!]
  previousValues: ApplyPreviousValues
}

input ApplySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ApplyWhereInput
  AND: [ApplySubscriptionWhereInput!]
  OR: [ApplySubscriptionWhereInput!]
  NOT: [ApplySubscriptionWhereInput!]
}

input ApplyUpdateInput {
  team: TeamUpdateOneInput
  match: MatchUpdateOneInput
}

input ApplyWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  team: TeamWhereInput
  match: MatchWhereInput
  AND: [ApplyWhereInput!]
  OR: [ApplyWhereInput!]
  NOT: [ApplyWhereInput!]
}

input ApplyWhereUniqueInput {
  seq: Int
}

enum Area {
  SB
  SN
  DN
  DB
}

type BatchPayload {
  count: Long!
}

scalar Long

type Match {
  seq: Int!
  host: Team
  guest: Team
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

type MatchConnection {
  pageInfo: PageInfo!
  edges: [MatchEdge]!
  aggregate: AggregateMatch!
}

input MatchCreateInput {
  seq: Int
  host: TeamCreateOneInput
  guest: TeamCreateOneInput
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchCreateOneInput {
  create: MatchCreateInput
  connect: MatchWhereUniqueInput
}

type MatchEdge {
  node: Match!
  cursor: String!
}

enum MatchOrderByInput {
  seq_ASC
  seq_DESC
  stadium_ASC
  stadium_DESC
  area_ASC
  area_DESC
  date_ASC
  date_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
  description_ASC
  description_DESC
  result_ASC
  result_DESC
}

type MatchPreviousValues {
  seq: Int!
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

type MatchSubscriptionPayload {
  mutation: MutationType!
  node: Match
  updatedFields: [String!]
  previousValues: MatchPreviousValues
}

input MatchSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatchWhereInput
  AND: [MatchSubscriptionWhereInput!]
  OR: [MatchSubscriptionWhereInput!]
  NOT: [MatchSubscriptionWhereInput!]
}

input MatchUpdateDataInput {
  host: TeamUpdateOneInput
  guest: TeamUpdateOneInput
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateInput {
  host: TeamUpdateOneInput
  guest: TeamUpdateOneInput
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateManyMutationInput {
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateOneInput {
  create: MatchCreateInput
  update: MatchUpdateDataInput
  upsert: MatchUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MatchWhereUniqueInput
}

input MatchUpsertNestedInput {
  update: MatchUpdateDataInput!
  create: MatchCreateInput!
}

input MatchWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  host: TeamWhereInput
  guest: TeamWhereInput
  stadium: String
  stadium_not: String
  stadium_in: [String!]
  stadium_not_in: [String!]
  stadium_lt: String
  stadium_lte: String
  stadium_gt: String
  stadium_gte: String
  stadium_contains: String
  stadium_not_contains: String
  stadium_starts_with: String
  stadium_not_starts_with: String
  stadium_ends_with: String
  stadium_not_ends_with: String
  area: Area
  area_not: Area
  area_in: [Area!]
  area_not_in: [Area!]
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  AND: [MatchWhereInput!]
  OR: [MatchWhereInput!]
  NOT: [MatchWhereInput!]
}

input MatchWhereUniqueInput {
  seq: Int
}

type Mutation {
  createApply(data: ApplyCreateInput!): Apply!
  updateApply(data: ApplyUpdateInput!, where: ApplyWhereUniqueInput!): Apply
  upsertApply(where: ApplyWhereUniqueInput!, create: ApplyCreateInput!, update: ApplyUpdateInput!): Apply!
  deleteApply(where: ApplyWhereUniqueInput!): Apply
  deleteManyApplies(where: ApplyWhereInput): BatchPayload!
  createMatch(data: MatchCreateInput!): Match!
  updateMatch(data: MatchUpdateInput!, where: MatchWhereUniqueInput!): Match
  updateManyMatches(data: MatchUpdateManyMutationInput!, where: MatchWhereInput): BatchPayload!
  upsertMatch(where: MatchWhereUniqueInput!, create: MatchCreateInput!, update: MatchUpdateInput!): Match!
  deleteMatch(where: MatchWhereUniqueInput!): Match
  deleteManyMatches(where: MatchWhereInput): BatchPayload!
  createNotifier(data: NotifierCreateInput!): Notifier!
  updateNotifier(data: NotifierUpdateInput!, where: NotifierWhereUniqueInput!): Notifier
  updateManyNotifiers(data: NotifierUpdateManyMutationInput!, where: NotifierWhereInput): BatchPayload!
  upsertNotifier(where: NotifierWhereUniqueInput!, create: NotifierCreateInput!, update: NotifierUpdateInput!): Notifier!
  deleteNotifier(where: NotifierWhereUniqueInput!): Notifier
  deleteManyNotifiers(where: NotifierWhereInput): BatchPayload!
  createPlayer(data: PlayerCreateInput!): Player!
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  updateManyPlayers(data: PlayerUpdateManyMutationInput!, where: PlayerWhereInput): BatchPayload!
  upsertPlayer(where: PlayerWhereUniqueInput!, create: PlayerCreateInput!, update: PlayerUpdateInput!): Player!
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  createStadium(data: StadiumCreateInput!): Stadium!
  updateStadium(data: StadiumUpdateInput!, where: StadiumWhereUniqueInput!): Stadium
  updateManyStadiums(data: StadiumUpdateManyMutationInput!, where: StadiumWhereInput): BatchPayload!
  upsertStadium(where: StadiumWhereUniqueInput!, create: StadiumCreateInput!, update: StadiumUpdateInput!): Stadium!
  deleteStadium(where: StadiumWhereUniqueInput!): Stadium
  deleteManyStadiums(where: StadiumWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Notifier {
  seq: Int!
  player: Player!
  area: Area
  date: String
  startTime: String
  endTime: String
}

type NotifierConnection {
  pageInfo: PageInfo!
  edges: [NotifierEdge]!
  aggregate: AggregateNotifier!
}

input NotifierCreateInput {
  seq: Int
  player: PlayerCreateOneInput!
  area: Area
  date: String
  startTime: String
  endTime: String
}

type NotifierEdge {
  node: Notifier!
  cursor: String!
}

enum NotifierOrderByInput {
  seq_ASC
  seq_DESC
  area_ASC
  area_DESC
  date_ASC
  date_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
}

type NotifierPreviousValues {
  seq: Int!
  area: Area
  date: String
  startTime: String
  endTime: String
}

type NotifierSubscriptionPayload {
  mutation: MutationType!
  node: Notifier
  updatedFields: [String!]
  previousValues: NotifierPreviousValues
}

input NotifierSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotifierWhereInput
  AND: [NotifierSubscriptionWhereInput!]
  OR: [NotifierSubscriptionWhereInput!]
  NOT: [NotifierSubscriptionWhereInput!]
}

input NotifierUpdateInput {
  player: PlayerUpdateOneRequiredInput
  area: Area
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateManyMutationInput {
  area: Area
  date: String
  startTime: String
  endTime: String
}

input NotifierWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  player: PlayerWhereInput
  area: Area
  area_not: Area
  area_in: [Area!]
  area_not_in: [Area!]
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  AND: [NotifierWhereInput!]
  OR: [NotifierWhereInput!]
  NOT: [NotifierWhereInput!]
}

input NotifierWhereUniqueInput {
  seq: Int
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  seq: Int!
  playerId: String!
  team: Team
  name: String!
  phone: String
}

type PlayerConnection {
  pageInfo: PageInfo!
  edges: [PlayerEdge]!
  aggregate: AggregatePlayer!
}

input PlayerCreateInput {
  seq: Int
  playerId: String!
  team: TeamCreateOneInput
  name: String!
  phone: String
}

input PlayerCreateOneInput {
  create: PlayerCreateInput
  connect: PlayerWhereUniqueInput
}

type PlayerEdge {
  node: Player!
  cursor: String!
}

enum PlayerOrderByInput {
  seq_ASC
  seq_DESC
  playerId_ASC
  playerId_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
}

type PlayerPreviousValues {
  seq: Int!
  playerId: String!
  name: String!
  phone: String
}

type PlayerSubscriptionPayload {
  mutation: MutationType!
  node: Player
  updatedFields: [String!]
  previousValues: PlayerPreviousValues
}

input PlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerWhereInput
  AND: [PlayerSubscriptionWhereInput!]
  OR: [PlayerSubscriptionWhereInput!]
  NOT: [PlayerSubscriptionWhereInput!]
}

input PlayerUpdateDataInput {
  playerId: String
  team: TeamUpdateOneInput
  name: String
  phone: String
}

input PlayerUpdateInput {
  playerId: String
  team: TeamUpdateOneInput
  name: String
  phone: String
}

input PlayerUpdateManyMutationInput {
  playerId: String
  name: String
  phone: String
}

input PlayerUpdateOneRequiredInput {
  create: PlayerCreateInput
  update: PlayerUpdateDataInput
  upsert: PlayerUpsertNestedInput
  connect: PlayerWhereUniqueInput
}

input PlayerUpsertNestedInput {
  update: PlayerUpdateDataInput!
  create: PlayerCreateInput!
}

input PlayerWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  playerId: String
  playerId_not: String
  playerId_in: [String!]
  playerId_not_in: [String!]
  playerId_lt: String
  playerId_lte: String
  playerId_gt: String
  playerId_gte: String
  playerId_contains: String
  playerId_not_contains: String
  playerId_starts_with: String
  playerId_not_starts_with: String
  playerId_ends_with: String
  playerId_not_ends_with: String
  team: TeamWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  AND: [PlayerWhereInput!]
  OR: [PlayerWhereInput!]
  NOT: [PlayerWhereInput!]
}

input PlayerWhereUniqueInput {
  seq: Int
  playerId: String
}

type Query {
  apply(where: ApplyWhereUniqueInput!): Apply
  applies(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Apply]!
  appliesConnection(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ApplyConnection!
  match(where: MatchWhereUniqueInput!): Match
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match]!
  matchesConnection(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatchConnection!
  notifier(where: NotifierWhereUniqueInput!): Notifier
  notifiers(where: NotifierWhereInput, orderBy: NotifierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notifier]!
  notifiersConnection(where: NotifierWhereInput, orderBy: NotifierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotifierConnection!
  player(where: PlayerWhereUniqueInput!): Player
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player]!
  playersConnection(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerConnection!
  stadium(where: StadiumWhereUniqueInput!): Stadium
  stadiums(where: StadiumWhereInput, orderBy: StadiumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stadium]!
  stadiumsConnection(where: StadiumWhereInput, orderBy: StadiumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StadiumConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  node(id: ID!): Node
}

enum Result {
  WIN
  DRAW
  LOSE
}

type Stadium {
  seq: Int!
  name: String
  address: String
}

type StadiumConnection {
  pageInfo: PageInfo!
  edges: [StadiumEdge]!
  aggregate: AggregateStadium!
}

input StadiumCreateInput {
  seq: Int
  name: String
  address: String
}

type StadiumEdge {
  node: Stadium!
  cursor: String!
}

enum StadiumOrderByInput {
  seq_ASC
  seq_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
}

type StadiumPreviousValues {
  seq: Int!
  name: String
  address: String
}

type StadiumSubscriptionPayload {
  mutation: MutationType!
  node: Stadium
  updatedFields: [String!]
  previousValues: StadiumPreviousValues
}

input StadiumSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StadiumWhereInput
  AND: [StadiumSubscriptionWhereInput!]
  OR: [StadiumSubscriptionWhereInput!]
  NOT: [StadiumSubscriptionWhereInput!]
}

input StadiumUpdateInput {
  name: String
  address: String
}

input StadiumUpdateManyMutationInput {
  name: String
  address: String
}

input StadiumWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [StadiumWhereInput!]
  OR: [StadiumWhereInput!]
  NOT: [StadiumWhereInput!]
}

input StadiumWhereUniqueInput {
  seq: Int
}

type Subscription {
  apply(where: ApplySubscriptionWhereInput): ApplySubscriptionPayload
  match(where: MatchSubscriptionWhereInput): MatchSubscriptionPayload
  notifier(where: NotifierSubscriptionWhereInput): NotifierSubscriptionPayload
  player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
  stadium(where: StadiumSubscriptionWhereInput): StadiumSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
}

type Team {
  seq: Int!
  name: String!
  logo: String
  home_area: Area
  introduction: String
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  seq: Int
  name: String!
  logo: String
  home_area: Area
  introduction: String
}

input TeamCreateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  seq_ASC
  seq_DESC
  name_ASC
  name_DESC
  logo_ASC
  logo_DESC
  home_area_ASC
  home_area_DESC
  introduction_ASC
  introduction_DESC
}

type TeamPreviousValues {
  seq: Int!
  name: String!
  logo: String
  home_area: Area
  introduction: String
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateDataInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
}

input TeamUpdateInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
}

input TeamUpdateManyMutationInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
}

input TeamUpdateOneInput {
  create: TeamCreateInput
  update: TeamUpdateDataInput
  upsert: TeamUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpsertNestedInput {
  update: TeamUpdateDataInput!
  create: TeamCreateInput!
}

input TeamWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  logo: String
  logo_not: String
  logo_in: [String!]
  logo_not_in: [String!]
  logo_lt: String
  logo_lte: String
  logo_gt: String
  logo_gte: String
  logo_contains: String
  logo_not_contains: String
  logo_starts_with: String
  logo_not_starts_with: String
  logo_ends_with: String
  logo_not_ends_with: String
  home_area: Area
  home_area_not: Area
  home_area_in: [Area!]
  home_area_not_in: [Area!]
  introduction: String
  introduction_not: String
  introduction_in: [String!]
  introduction_not_in: [String!]
  introduction_lt: String
  introduction_lte: String
  introduction_gt: String
  introduction_gte: String
  introduction_contains: String
  introduction_not_contains: String
  introduction_starts_with: String
  introduction_not_starts_with: String
  introduction_ends_with: String
  introduction_not_ends_with: String
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  seq: Int
}
`
      }
    