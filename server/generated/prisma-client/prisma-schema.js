module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateApply {
  count: Int!
}

type AggregateMatch {
  count: Int!
}

type AggregateNotifier {
  count: Int!
}

type AggregatePlayer {
  count: Int!
}

type AggregateStadium {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type Apply {
  seq: Int!
  team: Team
  match: Match
}

type ApplyConnection {
  pageInfo: PageInfo!
  edges: [ApplyEdge]!
  aggregate: AggregateApply!
}

input ApplyCreateInput {
  seq: Int
  team: TeamCreateOneWithoutApplyOn_listInput
  match: MatchCreateOneWithoutAppliedListsInput
}

input ApplyCreateManyWithoutMatchInput {
  create: [ApplyCreateWithoutMatchInput!]
  connect: [ApplyWhereUniqueInput!]
}

input ApplyCreateManyWithoutTeamInput {
  create: [ApplyCreateWithoutTeamInput!]
  connect: [ApplyWhereUniqueInput!]
}

input ApplyCreateWithoutMatchInput {
  seq: Int
  team: TeamCreateOneWithoutApplyOn_listInput
}

input ApplyCreateWithoutTeamInput {
  seq: Int
  match: MatchCreateOneWithoutAppliedListsInput
}

type ApplyEdge {
  node: Apply!
  cursor: String!
}

enum ApplyOrderByInput {
  seq_ASC
  seq_DESC
}

type ApplyPreviousValues {
  seq: Int!
}

input ApplyScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  AND: [ApplyScalarWhereInput!]
  OR: [ApplyScalarWhereInput!]
  NOT: [ApplyScalarWhereInput!]
}

type ApplySubscriptionPayload {
  mutation: MutationType!
  node: Apply
  updatedFields: [String!]
  previousValues: ApplyPreviousValues
}

input ApplySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ApplyWhereInput
  AND: [ApplySubscriptionWhereInput!]
  OR: [ApplySubscriptionWhereInput!]
  NOT: [ApplySubscriptionWhereInput!]
}

input ApplyUpdateInput {
  team: TeamUpdateOneWithoutApplyOn_listInput
  match: MatchUpdateOneWithoutAppliedListsInput
}

input ApplyUpdateManyWithoutMatchInput {
  create: [ApplyCreateWithoutMatchInput!]
  delete: [ApplyWhereUniqueInput!]
  connect: [ApplyWhereUniqueInput!]
  set: [ApplyWhereUniqueInput!]
  disconnect: [ApplyWhereUniqueInput!]
  update: [ApplyUpdateWithWhereUniqueWithoutMatchInput!]
  upsert: [ApplyUpsertWithWhereUniqueWithoutMatchInput!]
  deleteMany: [ApplyScalarWhereInput!]
}

input ApplyUpdateManyWithoutTeamInput {
  create: [ApplyCreateWithoutTeamInput!]
  delete: [ApplyWhereUniqueInput!]
  connect: [ApplyWhereUniqueInput!]
  set: [ApplyWhereUniqueInput!]
  disconnect: [ApplyWhereUniqueInput!]
  update: [ApplyUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [ApplyUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [ApplyScalarWhereInput!]
}

input ApplyUpdateWithoutMatchDataInput {
  team: TeamUpdateOneWithoutApplyOn_listInput
}

input ApplyUpdateWithoutTeamDataInput {
  match: MatchUpdateOneWithoutAppliedListsInput
}

input ApplyUpdateWithWhereUniqueWithoutMatchInput {
  where: ApplyWhereUniqueInput!
  data: ApplyUpdateWithoutMatchDataInput!
}

input ApplyUpdateWithWhereUniqueWithoutTeamInput {
  where: ApplyWhereUniqueInput!
  data: ApplyUpdateWithoutTeamDataInput!
}

input ApplyUpsertWithWhereUniqueWithoutMatchInput {
  where: ApplyWhereUniqueInput!
  update: ApplyUpdateWithoutMatchDataInput!
  create: ApplyCreateWithoutMatchInput!
}

input ApplyUpsertWithWhereUniqueWithoutTeamInput {
  where: ApplyWhereUniqueInput!
  update: ApplyUpdateWithoutTeamDataInput!
  create: ApplyCreateWithoutTeamInput!
}

input ApplyWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  team: TeamWhereInput
  match: MatchWhereInput
  AND: [ApplyWhereInput!]
  OR: [ApplyWhereInput!]
  NOT: [ApplyWhereInput!]
}

input ApplyWhereUniqueInput {
  seq: Int
}

enum Area {
  SB
  SN
  DN
  DB
}

type BatchPayload {
  count: Long!
}

scalar Long

type Match {
  seq: Int!
  host: Team
  guest: Team
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Apply!]
}

type MatchConnection {
  pageInfo: PageInfo!
  edges: [MatchEdge]!
  aggregate: AggregateMatch!
}

input MatchCreateInput {
  seq: Int
  host: TeamCreateOneWithoutUpload_match_listInput
  guest: TeamCreateOneWithoutApplyEnd_match_listInput
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyCreateManyWithoutMatchInput
}

input MatchCreateManyWithoutGuestInput {
  create: [MatchCreateWithoutGuestInput!]
  connect: [MatchWhereUniqueInput!]
}

input MatchCreateManyWithoutHostInput {
  create: [MatchCreateWithoutHostInput!]
  connect: [MatchWhereUniqueInput!]
}

input MatchCreateOneWithoutAppliedListsInput {
  create: MatchCreateWithoutAppliedListsInput
  connect: MatchWhereUniqueInput
}

input MatchCreateWithoutAppliedListsInput {
  seq: Int
  host: TeamCreateOneWithoutUpload_match_listInput
  guest: TeamCreateOneWithoutApplyEnd_match_listInput
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchCreateWithoutGuestInput {
  seq: Int
  host: TeamCreateOneWithoutUpload_match_listInput
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyCreateManyWithoutMatchInput
}

input MatchCreateWithoutHostInput {
  seq: Int
  guest: TeamCreateOneWithoutApplyEnd_match_listInput
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyCreateManyWithoutMatchInput
}

type MatchEdge {
  node: Match!
  cursor: String!
}

enum MatchOrderByInput {
  seq_ASC
  seq_DESC
  stadium_ASC
  stadium_DESC
  area_ASC
  area_DESC
  date_ASC
  date_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
  description_ASC
  description_DESC
  result_ASC
  result_DESC
}

type MatchPreviousValues {
  seq: Int!
  stadium: String!
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  stadium: String
  stadium_not: String
  stadium_in: [String!]
  stadium_not_in: [String!]
  stadium_lt: String
  stadium_lte: String
  stadium_gt: String
  stadium_gte: String
  stadium_contains: String
  stadium_not_contains: String
  stadium_starts_with: String
  stadium_not_starts_with: String
  stadium_ends_with: String
  stadium_not_ends_with: String
  area: Area
  area_not: Area
  area_in: [Area!]
  area_not_in: [Area!]
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  AND: [MatchScalarWhereInput!]
  OR: [MatchScalarWhereInput!]
  NOT: [MatchScalarWhereInput!]
}

type MatchSubscriptionPayload {
  mutation: MutationType!
  node: Match
  updatedFields: [String!]
  previousValues: MatchPreviousValues
}

input MatchSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatchWhereInput
  AND: [MatchSubscriptionWhereInput!]
  OR: [MatchSubscriptionWhereInput!]
  NOT: [MatchSubscriptionWhereInput!]
}

input MatchUpdateInput {
  host: TeamUpdateOneWithoutUpload_match_listInput
  guest: TeamUpdateOneWithoutApplyEnd_match_listInput
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyUpdateManyWithoutMatchInput
}

input MatchUpdateManyDataInput {
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateManyMutationInput {
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateManyWithoutGuestInput {
  create: [MatchCreateWithoutGuestInput!]
  delete: [MatchWhereUniqueInput!]
  connect: [MatchWhereUniqueInput!]
  set: [MatchWhereUniqueInput!]
  disconnect: [MatchWhereUniqueInput!]
  update: [MatchUpdateWithWhereUniqueWithoutGuestInput!]
  upsert: [MatchUpsertWithWhereUniqueWithoutGuestInput!]
  deleteMany: [MatchScalarWhereInput!]
  updateMany: [MatchUpdateManyWithWhereNestedInput!]
}

input MatchUpdateManyWithoutHostInput {
  create: [MatchCreateWithoutHostInput!]
  delete: [MatchWhereUniqueInput!]
  connect: [MatchWhereUniqueInput!]
  set: [MatchWhereUniqueInput!]
  disconnect: [MatchWhereUniqueInput!]
  update: [MatchUpdateWithWhereUniqueWithoutHostInput!]
  upsert: [MatchUpsertWithWhereUniqueWithoutHostInput!]
  deleteMany: [MatchScalarWhereInput!]
  updateMany: [MatchUpdateManyWithWhereNestedInput!]
}

input MatchUpdateManyWithWhereNestedInput {
  where: MatchScalarWhereInput!
  data: MatchUpdateManyDataInput!
}

input MatchUpdateOneWithoutAppliedListsInput {
  create: MatchCreateWithoutAppliedListsInput
  update: MatchUpdateWithoutAppliedListsDataInput
  upsert: MatchUpsertWithoutAppliedListsInput
  delete: Boolean
  disconnect: Boolean
  connect: MatchWhereUniqueInput
}

input MatchUpdateWithoutAppliedListsDataInput {
  host: TeamUpdateOneWithoutUpload_match_listInput
  guest: TeamUpdateOneWithoutApplyEnd_match_listInput
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
}

input MatchUpdateWithoutGuestDataInput {
  host: TeamUpdateOneWithoutUpload_match_listInput
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyUpdateManyWithoutMatchInput
}

input MatchUpdateWithoutHostDataInput {
  guest: TeamUpdateOneWithoutApplyEnd_match_listInput
  stadium: String
  area: Area
  date: String
  startTime: String
  endTime: String
  description: String
  result: Result
  appliedLists: ApplyUpdateManyWithoutMatchInput
}

input MatchUpdateWithWhereUniqueWithoutGuestInput {
  where: MatchWhereUniqueInput!
  data: MatchUpdateWithoutGuestDataInput!
}

input MatchUpdateWithWhereUniqueWithoutHostInput {
  where: MatchWhereUniqueInput!
  data: MatchUpdateWithoutHostDataInput!
}

input MatchUpsertWithoutAppliedListsInput {
  update: MatchUpdateWithoutAppliedListsDataInput!
  create: MatchCreateWithoutAppliedListsInput!
}

input MatchUpsertWithWhereUniqueWithoutGuestInput {
  where: MatchWhereUniqueInput!
  update: MatchUpdateWithoutGuestDataInput!
  create: MatchCreateWithoutGuestInput!
}

input MatchUpsertWithWhereUniqueWithoutHostInput {
  where: MatchWhereUniqueInput!
  update: MatchUpdateWithoutHostDataInput!
  create: MatchCreateWithoutHostInput!
}

input MatchWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  host: TeamWhereInput
  guest: TeamWhereInput
  stadium: String
  stadium_not: String
  stadium_in: [String!]
  stadium_not_in: [String!]
  stadium_lt: String
  stadium_lte: String
  stadium_gt: String
  stadium_gte: String
  stadium_contains: String
  stadium_not_contains: String
  stadium_starts_with: String
  stadium_not_starts_with: String
  stadium_ends_with: String
  stadium_not_ends_with: String
  area: Area
  area_not: Area
  area_in: [Area!]
  area_not_in: [Area!]
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  appliedLists_every: ApplyWhereInput
  appliedLists_some: ApplyWhereInput
  appliedLists_none: ApplyWhereInput
  AND: [MatchWhereInput!]
  OR: [MatchWhereInput!]
  NOT: [MatchWhereInput!]
}

input MatchWhereUniqueInput {
  seq: Int
}

type Mutation {
  createApply(data: ApplyCreateInput!): Apply!
  updateApply(data: ApplyUpdateInput!, where: ApplyWhereUniqueInput!): Apply
  upsertApply(where: ApplyWhereUniqueInput!, create: ApplyCreateInput!, update: ApplyUpdateInput!): Apply!
  deleteApply(where: ApplyWhereUniqueInput!): Apply
  deleteManyApplies(where: ApplyWhereInput): BatchPayload!
  createMatch(data: MatchCreateInput!): Match!
  updateMatch(data: MatchUpdateInput!, where: MatchWhereUniqueInput!): Match
  updateManyMatches(data: MatchUpdateManyMutationInput!, where: MatchWhereInput): BatchPayload!
  upsertMatch(where: MatchWhereUniqueInput!, create: MatchCreateInput!, update: MatchUpdateInput!): Match!
  deleteMatch(where: MatchWhereUniqueInput!): Match
  deleteManyMatches(where: MatchWhereInput): BatchPayload!
  createNotifier(data: NotifierCreateInput!): Notifier!
  updateNotifier(data: NotifierUpdateInput!, where: NotifierWhereUniqueInput!): Notifier
  updateManyNotifiers(data: NotifierUpdateManyMutationInput!, where: NotifierWhereInput): BatchPayload!
  upsertNotifier(where: NotifierWhereUniqueInput!, create: NotifierCreateInput!, update: NotifierUpdateInput!): Notifier!
  deleteNotifier(where: NotifierWhereUniqueInput!): Notifier
  deleteManyNotifiers(where: NotifierWhereInput): BatchPayload!
  createPlayer(data: PlayerCreateInput!): Player!
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  updateManyPlayers(data: PlayerUpdateManyMutationInput!, where: PlayerWhereInput): BatchPayload!
  upsertPlayer(where: PlayerWhereUniqueInput!, create: PlayerCreateInput!, update: PlayerUpdateInput!): Player!
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  createStadium(data: StadiumCreateInput!): Stadium!
  updateStadium(data: StadiumUpdateInput!, where: StadiumWhereUniqueInput!): Stadium
  updateManyStadiums(data: StadiumUpdateManyMutationInput!, where: StadiumWhereInput): BatchPayload!
  upsertStadium(where: StadiumWhereUniqueInput!, create: StadiumCreateInput!, update: StadiumUpdateInput!): Stadium!
  deleteStadium(where: StadiumWhereUniqueInput!): Stadium
  deleteManyStadiums(where: StadiumWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Notifier {
  seq: Int!
  player: Player!
  area: Area
  date: String
  startTime: String
  endTime: String
}

type NotifierConnection {
  pageInfo: PageInfo!
  edges: [NotifierEdge]!
  aggregate: AggregateNotifier!
}

input NotifierCreateInput {
  seq: Int
  player: PlayerCreateOneWithoutNoti_listInput!
  area: Area
  date: String
  startTime: String
  endTime: String
}

input NotifierCreateManyWithoutPlayerInput {
  create: [NotifierCreateWithoutPlayerInput!]
  connect: [NotifierWhereUniqueInput!]
}

input NotifierCreateWithoutPlayerInput {
  seq: Int
  area: Area
  date: String
  startTime: String
  endTime: String
}

type NotifierEdge {
  node: Notifier!
  cursor: String!
}

enum NotifierOrderByInput {
  seq_ASC
  seq_DESC
  area_ASC
  area_DESC
  date_ASC
  date_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
}

type NotifierPreviousValues {
  seq: Int!
  area: Area
  date: String
  startTime: String
  endTime: String
}

input NotifierScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  area: Area
  area_not: Area
  area_in: [Area!]
  area_not_in: [Area!]
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  AND: [NotifierScalarWhereInput!]
  OR: [NotifierScalarWhereInput!]
  NOT: [NotifierScalarWhereInput!]
}

type NotifierSubscriptionPayload {
  mutation: MutationType!
  node: Notifier
  updatedFields: [String!]
  previousValues: NotifierPreviousValues
}

input NotifierSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotifierWhereInput
  AND: [NotifierSubscriptionWhereInput!]
  OR: [NotifierSubscriptionWhereInput!]
  NOT: [NotifierSubscriptionWhereInput!]
}

input NotifierUpdateInput {
  player: PlayerUpdateOneRequiredWithoutNoti_listInput
  area: Area
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateManyDataInput {
  area: Area
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateManyMutationInput {
  area: Area
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateManyWithoutPlayerInput {
  create: [NotifierCreateWithoutPlayerInput!]
  delete: [NotifierWhereUniqueInput!]
  connect: [NotifierWhereUniqueInput!]
  set: [NotifierWhereUniqueInput!]
  disconnect: [NotifierWhereUniqueInput!]
  update: [NotifierUpdateWithWhereUniqueWithoutPlayerInput!]
  upsert: [NotifierUpsertWithWhereUniqueWithoutPlayerInput!]
  deleteMany: [NotifierScalarWhereInput!]
  updateMany: [NotifierUpdateManyWithWhereNestedInput!]
}

input NotifierUpdateManyWithWhereNestedInput {
  where: NotifierScalarWhereInput!
  data: NotifierUpdateManyDataInput!
}

input NotifierUpdateWithoutPlayerDataInput {
  area: Area
  date: String
  startTime: String
  endTime: String
}

input NotifierUpdateWithWhereUniqueWithoutPlayerInput {
  where: NotifierWhereUniqueInput!
  data: NotifierUpdateWithoutPlayerDataInput!
}

input NotifierUpsertWithWhereUniqueWithoutPlayerInput {
  where: NotifierWhereUniqueInput!
  update: NotifierUpdateWithoutPlayerDataInput!
  create: NotifierCreateWithoutPlayerInput!
}

input NotifierWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  player: PlayerWhereInput
  area: Area
  area_not: Area
  area_in: [Area!]
  area_not_in: [Area!]
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  AND: [NotifierWhereInput!]
  OR: [NotifierWhereInput!]
  NOT: [NotifierWhereInput!]
}

input NotifierWhereUniqueInput {
  seq: Int
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  seq: Int!
  playerId: String!
  team: Team
  name: String
  phone: String
  email: String
  noti_list(where: NotifierWhereInput, orderBy: NotifierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notifier!]
}

type PlayerConnection {
  pageInfo: PageInfo!
  edges: [PlayerEdge]!
  aggregate: AggregatePlayer!
}

input PlayerCreateInput {
  seq: Int
  playerId: String!
  team: TeamCreateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  noti_list: NotifierCreateManyWithoutPlayerInput
}

input PlayerCreateManyWithoutTeamInput {
  create: [PlayerCreateWithoutTeamInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateOneWithoutNoti_listInput {
  create: PlayerCreateWithoutNoti_listInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateWithoutNoti_listInput {
  seq: Int
  playerId: String!
  team: TeamCreateOneWithoutMembersInput
  name: String
  phone: String
  email: String
}

input PlayerCreateWithoutTeamInput {
  seq: Int
  playerId: String!
  name: String
  phone: String
  email: String
  noti_list: NotifierCreateManyWithoutPlayerInput
}

type PlayerEdge {
  node: Player!
  cursor: String!
}

enum PlayerOrderByInput {
  seq_ASC
  seq_DESC
  playerId_ASC
  playerId_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
  email_ASC
  email_DESC
}

type PlayerPreviousValues {
  seq: Int!
  playerId: String!
  name: String
  phone: String
  email: String
}

input PlayerScalarWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  playerId: String
  playerId_not: String
  playerId_in: [String!]
  playerId_not_in: [String!]
  playerId_lt: String
  playerId_lte: String
  playerId_gt: String
  playerId_gte: String
  playerId_contains: String
  playerId_not_contains: String
  playerId_starts_with: String
  playerId_not_starts_with: String
  playerId_ends_with: String
  playerId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  AND: [PlayerScalarWhereInput!]
  OR: [PlayerScalarWhereInput!]
  NOT: [PlayerScalarWhereInput!]
}

type PlayerSubscriptionPayload {
  mutation: MutationType!
  node: Player
  updatedFields: [String!]
  previousValues: PlayerPreviousValues
}

input PlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerWhereInput
  AND: [PlayerSubscriptionWhereInput!]
  OR: [PlayerSubscriptionWhereInput!]
  NOT: [PlayerSubscriptionWhereInput!]
}

input PlayerUpdateInput {
  playerId: String
  team: TeamUpdateOneWithoutMembersInput
  name: String
  phone: String
  email: String
  noti_list: NotifierUpdateManyWithoutPlayerInput
}

input PlayerUpdateManyDataInput {
  playerId: String
  name: String
  phone: String
  email: String
}

input PlayerUpdateManyMutationInput {
  playerId: String
  name: String
  phone: String
  email: String
}

input PlayerUpdateManyWithoutTeamInput {
  create: [PlayerCreateWithoutTeamInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput!
  data: PlayerUpdateManyDataInput!
}

input PlayerUpdateOneRequiredWithoutNoti_listInput {
  create: PlayerCreateWithoutNoti_listInput
  update: PlayerUpdateWithoutNoti_listDataInput
  upsert: PlayerUpsertWithoutNoti_listInput
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateWithoutNoti_listDataInput {
  playerId: String
  team: TeamUpdateOneWithoutMembersInput
  name: String
  phone: String
  email: String
}

input PlayerUpdateWithoutTeamDataInput {
  playerId: String
  name: String
  phone: String
  email: String
  noti_list: NotifierUpdateManyWithoutPlayerInput
}

input PlayerUpdateWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutTeamDataInput!
}

input PlayerUpsertWithoutNoti_listInput {
  update: PlayerUpdateWithoutNoti_listDataInput!
  create: PlayerCreateWithoutNoti_listInput!
}

input PlayerUpsertWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutTeamDataInput!
  create: PlayerCreateWithoutTeamInput!
}

input PlayerWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  playerId: String
  playerId_not: String
  playerId_in: [String!]
  playerId_not_in: [String!]
  playerId_lt: String
  playerId_lte: String
  playerId_gt: String
  playerId_gte: String
  playerId_contains: String
  playerId_not_contains: String
  playerId_starts_with: String
  playerId_not_starts_with: String
  playerId_ends_with: String
  playerId_not_ends_with: String
  team: TeamWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  noti_list_every: NotifierWhereInput
  noti_list_some: NotifierWhereInput
  noti_list_none: NotifierWhereInput
  AND: [PlayerWhereInput!]
  OR: [PlayerWhereInput!]
  NOT: [PlayerWhereInput!]
}

input PlayerWhereUniqueInput {
  seq: Int
  playerId: String
  email: String
}

type Query {
  apply(where: ApplyWhereUniqueInput!): Apply
  applies(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Apply]!
  appliesConnection(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ApplyConnection!
  match(where: MatchWhereUniqueInput!): Match
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match]!
  matchesConnection(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatchConnection!
  notifier(where: NotifierWhereUniqueInput!): Notifier
  notifiers(where: NotifierWhereInput, orderBy: NotifierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notifier]!
  notifiersConnection(where: NotifierWhereInput, orderBy: NotifierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotifierConnection!
  player(where: PlayerWhereUniqueInput!): Player
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player]!
  playersConnection(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerConnection!
  stadium(where: StadiumWhereUniqueInput!): Stadium
  stadiums(where: StadiumWhereInput, orderBy: StadiumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stadium]!
  stadiumsConnection(where: StadiumWhereInput, orderBy: StadiumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StadiumConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  node(id: ID!): Node
}

enum Result {
  WIN
  DRAW
  LOSE
}

type Stadium {
  seq: Int!
  name: String
  address: String
}

type StadiumConnection {
  pageInfo: PageInfo!
  edges: [StadiumEdge]!
  aggregate: AggregateStadium!
}

input StadiumCreateInput {
  seq: Int
  name: String
  address: String
}

type StadiumEdge {
  node: Stadium!
  cursor: String!
}

enum StadiumOrderByInput {
  seq_ASC
  seq_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
}

type StadiumPreviousValues {
  seq: Int!
  name: String
  address: String
}

type StadiumSubscriptionPayload {
  mutation: MutationType!
  node: Stadium
  updatedFields: [String!]
  previousValues: StadiumPreviousValues
}

input StadiumSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StadiumWhereInput
  AND: [StadiumSubscriptionWhereInput!]
  OR: [StadiumSubscriptionWhereInput!]
  NOT: [StadiumSubscriptionWhereInput!]
}

input StadiumUpdateInput {
  name: String
  address: String
}

input StadiumUpdateManyMutationInput {
  name: String
  address: String
}

input StadiumWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [StadiumWhereInput!]
  OR: [StadiumWhereInput!]
  NOT: [StadiumWhereInput!]
}

input StadiumWhereUniqueInput {
  seq: Int
}

type Subscription {
  apply(where: ApplySubscriptionWhereInput): ApplySubscriptionPayload
  match(where: MatchSubscriptionWhereInput): MatchSubscriptionPayload
  notifier(where: NotifierSubscriptionWhereInput): NotifierSubscriptionPayload
  player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
  stadium(where: StadiumSubscriptionWhereInput): StadiumSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
}

type Team {
  seq: Int!
  name: String!
  logo: String
  home_area: Area
  introduction: String
  members(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
  upload_match_list(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match!]
  applyEnd_match_list(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match!]
  applyOn_list(where: ApplyWhereInput, orderBy: ApplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Apply!]
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  seq: Int
  name: String!
  logo: String
  home_area: Area
  introduction: String
  members: PlayerCreateManyWithoutTeamInput
  upload_match_list: MatchCreateManyWithoutHostInput
  applyEnd_match_list: MatchCreateManyWithoutGuestInput
  applyOn_list: ApplyCreateManyWithoutTeamInput
}

input TeamCreateOneWithoutApplyEnd_match_listInput {
  create: TeamCreateWithoutApplyEnd_match_listInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutApplyOn_listInput {
  create: TeamCreateWithoutApplyOn_listInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutMembersInput {
  create: TeamCreateWithoutMembersInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutUpload_match_listInput {
  create: TeamCreateWithoutUpload_match_listInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutApplyEnd_match_listInput {
  seq: Int
  name: String!
  logo: String
  home_area: Area
  introduction: String
  members: PlayerCreateManyWithoutTeamInput
  upload_match_list: MatchCreateManyWithoutHostInput
  applyOn_list: ApplyCreateManyWithoutTeamInput
}

input TeamCreateWithoutApplyOn_listInput {
  seq: Int
  name: String!
  logo: String
  home_area: Area
  introduction: String
  members: PlayerCreateManyWithoutTeamInput
  upload_match_list: MatchCreateManyWithoutHostInput
  applyEnd_match_list: MatchCreateManyWithoutGuestInput
}

input TeamCreateWithoutMembersInput {
  seq: Int
  name: String!
  logo: String
  home_area: Area
  introduction: String
  upload_match_list: MatchCreateManyWithoutHostInput
  applyEnd_match_list: MatchCreateManyWithoutGuestInput
  applyOn_list: ApplyCreateManyWithoutTeamInput
}

input TeamCreateWithoutUpload_match_listInput {
  seq: Int
  name: String!
  logo: String
  home_area: Area
  introduction: String
  members: PlayerCreateManyWithoutTeamInput
  applyEnd_match_list: MatchCreateManyWithoutGuestInput
  applyOn_list: ApplyCreateManyWithoutTeamInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  seq_ASC
  seq_DESC
  name_ASC
  name_DESC
  logo_ASC
  logo_DESC
  home_area_ASC
  home_area_DESC
  introduction_ASC
  introduction_DESC
}

type TeamPreviousValues {
  seq: Int!
  name: String!
  logo: String
  home_area: Area
  introduction: String
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
  members: PlayerUpdateManyWithoutTeamInput
  upload_match_list: MatchUpdateManyWithoutHostInput
  applyEnd_match_list: MatchUpdateManyWithoutGuestInput
  applyOn_list: ApplyUpdateManyWithoutTeamInput
}

input TeamUpdateManyMutationInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
}

input TeamUpdateOneWithoutApplyEnd_match_listInput {
  create: TeamCreateWithoutApplyEnd_match_listInput
  update: TeamUpdateWithoutApplyEnd_match_listDataInput
  upsert: TeamUpsertWithoutApplyEnd_match_listInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutApplyOn_listInput {
  create: TeamCreateWithoutApplyOn_listInput
  update: TeamUpdateWithoutApplyOn_listDataInput
  upsert: TeamUpsertWithoutApplyOn_listInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutMembersInput {
  create: TeamCreateWithoutMembersInput
  update: TeamUpdateWithoutMembersDataInput
  upsert: TeamUpsertWithoutMembersInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutUpload_match_listInput {
  create: TeamCreateWithoutUpload_match_listInput
  update: TeamUpdateWithoutUpload_match_listDataInput
  upsert: TeamUpsertWithoutUpload_match_listInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutApplyEnd_match_listDataInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
  members: PlayerUpdateManyWithoutTeamInput
  upload_match_list: MatchUpdateManyWithoutHostInput
  applyOn_list: ApplyUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutApplyOn_listDataInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
  members: PlayerUpdateManyWithoutTeamInput
  upload_match_list: MatchUpdateManyWithoutHostInput
  applyEnd_match_list: MatchUpdateManyWithoutGuestInput
}

input TeamUpdateWithoutMembersDataInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
  upload_match_list: MatchUpdateManyWithoutHostInput
  applyEnd_match_list: MatchUpdateManyWithoutGuestInput
  applyOn_list: ApplyUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutUpload_match_listDataInput {
  name: String
  logo: String
  home_area: Area
  introduction: String
  members: PlayerUpdateManyWithoutTeamInput
  applyEnd_match_list: MatchUpdateManyWithoutGuestInput
  applyOn_list: ApplyUpdateManyWithoutTeamInput
}

input TeamUpsertWithoutApplyEnd_match_listInput {
  update: TeamUpdateWithoutApplyEnd_match_listDataInput!
  create: TeamCreateWithoutApplyEnd_match_listInput!
}

input TeamUpsertWithoutApplyOn_listInput {
  update: TeamUpdateWithoutApplyOn_listDataInput!
  create: TeamCreateWithoutApplyOn_listInput!
}

input TeamUpsertWithoutMembersInput {
  update: TeamUpdateWithoutMembersDataInput!
  create: TeamCreateWithoutMembersInput!
}

input TeamUpsertWithoutUpload_match_listInput {
  update: TeamUpdateWithoutUpload_match_listDataInput!
  create: TeamCreateWithoutUpload_match_listInput!
}

input TeamWhereInput {
  seq: Int
  seq_not: Int
  seq_in: [Int!]
  seq_not_in: [Int!]
  seq_lt: Int
  seq_lte: Int
  seq_gt: Int
  seq_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  logo: String
  logo_not: String
  logo_in: [String!]
  logo_not_in: [String!]
  logo_lt: String
  logo_lte: String
  logo_gt: String
  logo_gte: String
  logo_contains: String
  logo_not_contains: String
  logo_starts_with: String
  logo_not_starts_with: String
  logo_ends_with: String
  logo_not_ends_with: String
  home_area: Area
  home_area_not: Area
  home_area_in: [Area!]
  home_area_not_in: [Area!]
  introduction: String
  introduction_not: String
  introduction_in: [String!]
  introduction_not_in: [String!]
  introduction_lt: String
  introduction_lte: String
  introduction_gt: String
  introduction_gte: String
  introduction_contains: String
  introduction_not_contains: String
  introduction_starts_with: String
  introduction_not_starts_with: String
  introduction_ends_with: String
  introduction_not_ends_with: String
  members_every: PlayerWhereInput
  members_some: PlayerWhereInput
  members_none: PlayerWhereInput
  upload_match_list_every: MatchWhereInput
  upload_match_list_some: MatchWhereInput
  upload_match_list_none: MatchWhereInput
  applyEnd_match_list_every: MatchWhereInput
  applyEnd_match_list_some: MatchWhereInput
  applyEnd_match_list_none: MatchWhereInput
  applyOn_list_every: ApplyWhereInput
  applyOn_list_some: ApplyWhereInput
  applyOn_list_none: ApplyWhereInput
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  seq: Int
}
`
      }
    