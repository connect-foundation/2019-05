module.exports = {
  // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  typeDefs:
    // Please don't change this file manually but run `prisma generate` to update it.
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

    /* GraphQL */ `
      type AggregateApply {
        count: Int!
      }

      type AggregateMatch {
        count: Int!
      }

      type AggregateNotifier {
        count: Int!
      }

      type AggregatePlayer {
        count: Int!
      }

      type AggregateStadium {
        count: Int!
      }

      type AggregateTeam {
        count: Int!
      }

      type Apply {
        seq: Int!
        team: Team
        match: Match
      }

      type ApplyConnection {
        pageInfo: PageInfo!
        edges: [ApplyEdge]!
        aggregate: AggregateApply!
      }

      input ApplyCreateInput {
        seq: Int
        team: TeamCreateOneWithoutOnApplyingListInput
        match: MatchCreateOneWithoutAppliedListsInput
      }

      input ApplyCreateManyWithoutMatchInput {
        create: [ApplyCreateWithoutMatchInput!]
        connect: [ApplyWhereUniqueInput!]
      }

      input ApplyCreateManyWithoutTeamInput {
        create: [ApplyCreateWithoutTeamInput!]
        connect: [ApplyWhereUniqueInput!]
      }

      input ApplyCreateWithoutMatchInput {
        seq: Int
        team: TeamCreateOneWithoutOnApplyingListInput
      }

      input ApplyCreateWithoutTeamInput {
        seq: Int
        match: MatchCreateOneWithoutAppliedListsInput
      }

      type ApplyEdge {
        node: Apply!
        cursor: String!
      }

      enum ApplyOrderByInput {
        seq_ASC
        seq_DESC
      }

      type ApplyPreviousValues {
        seq: Int!
      }

      input ApplyScalarWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        AND: [ApplyScalarWhereInput!]
        OR: [ApplyScalarWhereInput!]
        NOT: [ApplyScalarWhereInput!]
      }

      type ApplySubscriptionPayload {
        mutation: MutationType!
        node: Apply
        updatedFields: [String!]
        previousValues: ApplyPreviousValues
      }

      input ApplySubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: ApplyWhereInput
        AND: [ApplySubscriptionWhereInput!]
        OR: [ApplySubscriptionWhereInput!]
        NOT: [ApplySubscriptionWhereInput!]
      }

      input ApplyUpdateInput {
        team: TeamUpdateOneWithoutOnApplyingListInput
        match: MatchUpdateOneWithoutAppliedListsInput
      }

      input ApplyUpdateManyWithoutMatchInput {
        create: [ApplyCreateWithoutMatchInput!]
        delete: [ApplyWhereUniqueInput!]
        connect: [ApplyWhereUniqueInput!]
        set: [ApplyWhereUniqueInput!]
        disconnect: [ApplyWhereUniqueInput!]
        update: [ApplyUpdateWithWhereUniqueWithoutMatchInput!]
        upsert: [ApplyUpsertWithWhereUniqueWithoutMatchInput!]
        deleteMany: [ApplyScalarWhereInput!]
      }

      input ApplyUpdateManyWithoutTeamInput {
        create: [ApplyCreateWithoutTeamInput!]
        delete: [ApplyWhereUniqueInput!]
        connect: [ApplyWhereUniqueInput!]
        set: [ApplyWhereUniqueInput!]
        disconnect: [ApplyWhereUniqueInput!]
        update: [ApplyUpdateWithWhereUniqueWithoutTeamInput!]
        upsert: [ApplyUpsertWithWhereUniqueWithoutTeamInput!]
        deleteMany: [ApplyScalarWhereInput!]
      }

      input ApplyUpdateWithoutMatchDataInput {
        team: TeamUpdateOneWithoutOnApplyingListInput
      }

      input ApplyUpdateWithoutTeamDataInput {
        match: MatchUpdateOneWithoutAppliedListsInput
      }

      input ApplyUpdateWithWhereUniqueWithoutMatchInput {
        where: ApplyWhereUniqueInput!
        data: ApplyUpdateWithoutMatchDataInput!
      }

      input ApplyUpdateWithWhereUniqueWithoutTeamInput {
        where: ApplyWhereUniqueInput!
        data: ApplyUpdateWithoutTeamDataInput!
      }

      input ApplyUpsertWithWhereUniqueWithoutMatchInput {
        where: ApplyWhereUniqueInput!
        update: ApplyUpdateWithoutMatchDataInput!
        create: ApplyCreateWithoutMatchInput!
      }

      input ApplyUpsertWithWhereUniqueWithoutTeamInput {
        where: ApplyWhereUniqueInput!
        update: ApplyUpdateWithoutTeamDataInput!
        create: ApplyCreateWithoutTeamInput!
      }

      input ApplyWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        team: TeamWhereInput
        match: MatchWhereInput
        AND: [ApplyWhereInput!]
        OR: [ApplyWhereInput!]
        NOT: [ApplyWhereInput!]
      }

      input ApplyWhereUniqueInput {
        seq: Int
      }

      enum Area {
        SB
        SN
        DN
        DB
      }

      type BatchPayload {
        count: Long!
      }

      scalar Long

      type Match {
        seq: Int!
        host: Team
        guest: Team
        stadium: String!
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
        appliedLists(
          where: ApplyWhereInput
          orderBy: ApplyOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Apply!]
      }

      type MatchConnection {
        pageInfo: PageInfo!
        edges: [MatchEdge]!
        aggregate: AggregateMatch!
      }

      input MatchCreateInput {
        seq: Int
        host: TeamCreateOneWithoutUploadMatchListInput
        guest: TeamCreateOneWithoutMatchingDoneListInput
        stadium: String!
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
        appliedLists: ApplyCreateManyWithoutMatchInput
      }

      input MatchCreateManyWithoutGuestInput {
        create: [MatchCreateWithoutGuestInput!]
        connect: [MatchWhereUniqueInput!]
      }

      input MatchCreateManyWithoutHostInput {
        create: [MatchCreateWithoutHostInput!]
        connect: [MatchWhereUniqueInput!]
      }

      input MatchCreateOneWithoutAppliedListsInput {
        create: MatchCreateWithoutAppliedListsInput
        connect: MatchWhereUniqueInput
      }

      input MatchCreateWithoutAppliedListsInput {
        seq: Int
        host: TeamCreateOneWithoutUploadMatchListInput
        guest: TeamCreateOneWithoutMatchingDoneListInput
        stadium: String!
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
      }

      input MatchCreateWithoutGuestInput {
        seq: Int
        host: TeamCreateOneWithoutUploadMatchListInput
        stadium: String!
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
        appliedLists: ApplyCreateManyWithoutMatchInput
      }

      input MatchCreateWithoutHostInput {
        seq: Int
        guest: TeamCreateOneWithoutMatchingDoneListInput
        stadium: String!
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
        appliedLists: ApplyCreateManyWithoutMatchInput
      }

      type MatchEdge {
        node: Match!
        cursor: String!
      }

      enum MatchOrderByInput {
        seq_ASC
        seq_DESC
        stadium_ASC
        stadium_DESC
        address_ASC
        address_DESC
        area_ASC
        area_DESC
        date_ASC
        date_DESC
        startTime_ASC
        startTime_DESC
        endTime_ASC
        endTime_DESC
        description_ASC
        description_DESC
        result_ASC
        result_DESC
      }

      type MatchPreviousValues {
        seq: Int!
        stadium: String!
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
      }

      input MatchScalarWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        stadium: String
        stadium_not: String
        stadium_in: [String!]
        stadium_not_in: [String!]
        stadium_lt: String
        stadium_lte: String
        stadium_gt: String
        stadium_gte: String
        stadium_contains: String
        stadium_not_contains: String
        stadium_starts_with: String
        stadium_not_starts_with: String
        stadium_ends_with: String
        stadium_not_ends_with: String
        address: String
        address_not: String
        address_in: [String!]
        address_not_in: [String!]
        address_lt: String
        address_lte: String
        address_gt: String
        address_gte: String
        address_contains: String
        address_not_contains: String
        address_starts_with: String
        address_not_starts_with: String
        address_ends_with: String
        address_not_ends_with: String
        area: Area
        area_not: Area
        area_in: [Area!]
        area_not_in: [Area!]
        date: String
        date_not: String
        date_in: [String!]
        date_not_in: [String!]
        date_lt: String
        date_lte: String
        date_gt: String
        date_gte: String
        date_contains: String
        date_not_contains: String
        date_starts_with: String
        date_not_starts_with: String
        date_ends_with: String
        date_not_ends_with: String
        startTime: String
        startTime_not: String
        startTime_in: [String!]
        startTime_not_in: [String!]
        startTime_lt: String
        startTime_lte: String
        startTime_gt: String
        startTime_gte: String
        startTime_contains: String
        startTime_not_contains: String
        startTime_starts_with: String
        startTime_not_starts_with: String
        startTime_ends_with: String
        startTime_not_ends_with: String
        endTime: String
        endTime_not: String
        endTime_in: [String!]
        endTime_not_in: [String!]
        endTime_lt: String
        endTime_lte: String
        endTime_gt: String
        endTime_gte: String
        endTime_contains: String
        endTime_not_contains: String
        endTime_starts_with: String
        endTime_not_starts_with: String
        endTime_ends_with: String
        endTime_not_ends_with: String
        description: String
        description_not: String
        description_in: [String!]
        description_not_in: [String!]
        description_lt: String
        description_lte: String
        description_gt: String
        description_gte: String
        description_contains: String
        description_not_contains: String
        description_starts_with: String
        description_not_starts_with: String
        description_ends_with: String
        description_not_ends_with: String
        result: Result
        result_not: Result
        result_in: [Result!]
        result_not_in: [Result!]
        AND: [MatchScalarWhereInput!]
        OR: [MatchScalarWhereInput!]
        NOT: [MatchScalarWhereInput!]
      }

      type MatchSubscriptionPayload {
        mutation: MutationType!
        node: Match
        updatedFields: [String!]
        previousValues: MatchPreviousValues
      }

      input MatchSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: MatchWhereInput
        AND: [MatchSubscriptionWhereInput!]
        OR: [MatchSubscriptionWhereInput!]
        NOT: [MatchSubscriptionWhereInput!]
      }

      input MatchUpdateInput {
        host: TeamUpdateOneWithoutUploadMatchListInput
        guest: TeamUpdateOneWithoutMatchingDoneListInput
        stadium: String
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
        appliedLists: ApplyUpdateManyWithoutMatchInput
      }

      input MatchUpdateManyDataInput {
        stadium: String
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
      }

      input MatchUpdateManyMutationInput {
        stadium: String
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
      }

      input MatchUpdateManyWithoutGuestInput {
        create: [MatchCreateWithoutGuestInput!]
        delete: [MatchWhereUniqueInput!]
        connect: [MatchWhereUniqueInput!]
        set: [MatchWhereUniqueInput!]
        disconnect: [MatchWhereUniqueInput!]
        update: [MatchUpdateWithWhereUniqueWithoutGuestInput!]
        upsert: [MatchUpsertWithWhereUniqueWithoutGuestInput!]
        deleteMany: [MatchScalarWhereInput!]
        updateMany: [MatchUpdateManyWithWhereNestedInput!]
      }

      input MatchUpdateManyWithoutHostInput {
        create: [MatchCreateWithoutHostInput!]
        delete: [MatchWhereUniqueInput!]
        connect: [MatchWhereUniqueInput!]
        set: [MatchWhereUniqueInput!]
        disconnect: [MatchWhereUniqueInput!]
        update: [MatchUpdateWithWhereUniqueWithoutHostInput!]
        upsert: [MatchUpsertWithWhereUniqueWithoutHostInput!]
        deleteMany: [MatchScalarWhereInput!]
        updateMany: [MatchUpdateManyWithWhereNestedInput!]
      }

      input MatchUpdateManyWithWhereNestedInput {
        where: MatchScalarWhereInput!
        data: MatchUpdateManyDataInput!
      }

      input MatchUpdateOneWithoutAppliedListsInput {
        create: MatchCreateWithoutAppliedListsInput
        update: MatchUpdateWithoutAppliedListsDataInput
        upsert: MatchUpsertWithoutAppliedListsInput
        delete: Boolean
        disconnect: Boolean
        connect: MatchWhereUniqueInput
      }

      input MatchUpdateWithoutAppliedListsDataInput {
        host: TeamUpdateOneWithoutUploadMatchListInput
        guest: TeamUpdateOneWithoutMatchingDoneListInput
        stadium: String
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
      }

      input MatchUpdateWithoutGuestDataInput {
        host: TeamUpdateOneWithoutUploadMatchListInput
        stadium: String
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
        appliedLists: ApplyUpdateManyWithoutMatchInput
      }

      input MatchUpdateWithoutHostDataInput {
        guest: TeamUpdateOneWithoutMatchingDoneListInput
        stadium: String
        address: String
        area: Area
        date: String
        startTime: String
        endTime: String
        description: String
        result: Result
        appliedLists: ApplyUpdateManyWithoutMatchInput
      }

      input MatchUpdateWithWhereUniqueWithoutGuestInput {
        where: MatchWhereUniqueInput!
        data: MatchUpdateWithoutGuestDataInput!
      }

      input MatchUpdateWithWhereUniqueWithoutHostInput {
        where: MatchWhereUniqueInput!
        data: MatchUpdateWithoutHostDataInput!
      }

      input MatchUpsertWithoutAppliedListsInput {
        update: MatchUpdateWithoutAppliedListsDataInput!
        create: MatchCreateWithoutAppliedListsInput!
      }

      input MatchUpsertWithWhereUniqueWithoutGuestInput {
        where: MatchWhereUniqueInput!
        update: MatchUpdateWithoutGuestDataInput!
        create: MatchCreateWithoutGuestInput!
      }

      input MatchUpsertWithWhereUniqueWithoutHostInput {
        where: MatchWhereUniqueInput!
        update: MatchUpdateWithoutHostDataInput!
        create: MatchCreateWithoutHostInput!
      }

      input MatchWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        host: TeamWhereInput
        guest: TeamWhereInput
        stadium: String
        stadium_not: String
        stadium_in: [String!]
        stadium_not_in: [String!]
        stadium_lt: String
        stadium_lte: String
        stadium_gt: String
        stadium_gte: String
        stadium_contains: String
        stadium_not_contains: String
        stadium_starts_with: String
        stadium_not_starts_with: String
        stadium_ends_with: String
        stadium_not_ends_with: String
        address: String
        address_not: String
        address_in: [String!]
        address_not_in: [String!]
        address_lt: String
        address_lte: String
        address_gt: String
        address_gte: String
        address_contains: String
        address_not_contains: String
        address_starts_with: String
        address_not_starts_with: String
        address_ends_with: String
        address_not_ends_with: String
        area: Area
        area_not: Area
        area_in: [Area!]
        area_not_in: [Area!]
        date: String
        date_not: String
        date_in: [String!]
        date_not_in: [String!]
        date_lt: String
        date_lte: String
        date_gt: String
        date_gte: String
        date_contains: String
        date_not_contains: String
        date_starts_with: String
        date_not_starts_with: String
        date_ends_with: String
        date_not_ends_with: String
        startTime: String
        startTime_not: String
        startTime_in: [String!]
        startTime_not_in: [String!]
        startTime_lt: String
        startTime_lte: String
        startTime_gt: String
        startTime_gte: String
        startTime_contains: String
        startTime_not_contains: String
        startTime_starts_with: String
        startTime_not_starts_with: String
        startTime_ends_with: String
        startTime_not_ends_with: String
        endTime: String
        endTime_not: String
        endTime_in: [String!]
        endTime_not_in: [String!]
        endTime_lt: String
        endTime_lte: String
        endTime_gt: String
        endTime_gte: String
        endTime_contains: String
        endTime_not_contains: String
        endTime_starts_with: String
        endTime_not_starts_with: String
        endTime_ends_with: String
        endTime_not_ends_with: String
        description: String
        description_not: String
        description_in: [String!]
        description_not_in: [String!]
        description_lt: String
        description_lte: String
        description_gt: String
        description_gte: String
        description_contains: String
        description_not_contains: String
        description_starts_with: String
        description_not_starts_with: String
        description_ends_with: String
        description_not_ends_with: String
        result: Result
        result_not: Result
        result_in: [Result!]
        result_not_in: [Result!]
        appliedLists_every: ApplyWhereInput
        appliedLists_some: ApplyWhereInput
        appliedLists_none: ApplyWhereInput
        AND: [MatchWhereInput!]
        OR: [MatchWhereInput!]
        NOT: [MatchWhereInput!]
      }

      input MatchWhereUniqueInput {
        seq: Int
      }

      type Mutation {
        createApply(data: ApplyCreateInput!): Apply!
        updateApply(
          data: ApplyUpdateInput!
          where: ApplyWhereUniqueInput!
        ): Apply
        upsertApply(
          where: ApplyWhereUniqueInput!
          create: ApplyCreateInput!
          update: ApplyUpdateInput!
        ): Apply!
        deleteApply(where: ApplyWhereUniqueInput!): Apply
        deleteManyApplies(where: ApplyWhereInput): BatchPayload!
        createMatch(data: MatchCreateInput!): Match!
        updateMatch(
          data: MatchUpdateInput!
          where: MatchWhereUniqueInput!
        ): Match
        updateManyMatches(
          data: MatchUpdateManyMutationInput!
          where: MatchWhereInput
        ): BatchPayload!
        upsertMatch(
          where: MatchWhereUniqueInput!
          create: MatchCreateInput!
          update: MatchUpdateInput!
        ): Match!
        deleteMatch(where: MatchWhereUniqueInput!): Match
        deleteManyMatches(where: MatchWhereInput): BatchPayload!
        createNotifier(data: NotifierCreateInput!): Notifier!
        updateNotifier(
          data: NotifierUpdateInput!
          where: NotifierWhereUniqueInput!
        ): Notifier
        updateManyNotifiers(
          data: NotifierUpdateManyMutationInput!
          where: NotifierWhereInput
        ): BatchPayload!
        upsertNotifier(
          where: NotifierWhereUniqueInput!
          create: NotifierCreateInput!
          update: NotifierUpdateInput!
        ): Notifier!
        deleteNotifier(where: NotifierWhereUniqueInput!): Notifier
        deleteManyNotifiers(where: NotifierWhereInput): BatchPayload!
        createPlayer(data: PlayerCreateInput!): Player!
        updatePlayer(
          data: PlayerUpdateInput!
          where: PlayerWhereUniqueInput!
        ): Player
        updateManyPlayers(
          data: PlayerUpdateManyMutationInput!
          where: PlayerWhereInput
        ): BatchPayload!
        upsertPlayer(
          where: PlayerWhereUniqueInput!
          create: PlayerCreateInput!
          update: PlayerUpdateInput!
        ): Player!
        deletePlayer(where: PlayerWhereUniqueInput!): Player
        deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
        createStadium(data: StadiumCreateInput!): Stadium!
        updateStadium(
          data: StadiumUpdateInput!
          where: StadiumWhereUniqueInput!
        ): Stadium
        updateManyStadiums(
          data: StadiumUpdateManyMutationInput!
          where: StadiumWhereInput
        ): BatchPayload!
        upsertStadium(
          where: StadiumWhereUniqueInput!
          create: StadiumCreateInput!
          update: StadiumUpdateInput!
        ): Stadium!
        deleteStadium(where: StadiumWhereUniqueInput!): Stadium
        deleteManyStadiums(where: StadiumWhereInput): BatchPayload!
        createTeam(data: TeamCreateInput!): Team!
        updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
        updateManyTeams(
          data: TeamUpdateManyMutationInput!
          where: TeamWhereInput
        ): BatchPayload!
        upsertTeam(
          where: TeamWhereUniqueInput!
          create: TeamCreateInput!
          update: TeamUpdateInput!
        ): Team!
        deleteTeam(where: TeamWhereUniqueInput!): Team
        deleteManyTeams(where: TeamWhereInput): BatchPayload!
      }

      enum MutationType {
        CREATED
        UPDATED
        DELETED
      }

      interface Node {
        id: ID!
      }

      type Notifier {
        seq: Int!
        player: Player!
        area: [Area!]!
        date: String
        startTime: String
        endTime: String
      }

      type NotifierConnection {
        pageInfo: PageInfo!
        edges: [NotifierEdge]!
        aggregate: AggregateNotifier!
      }

      input NotifierCreateareaInput {
        set: [Area!]
      }

      input NotifierCreateInput {
        seq: Int
        player: PlayerCreateOneWithoutNotiListInput!
        area: NotifierCreateareaInput
        date: String
        startTime: String
        endTime: String
      }

      input NotifierCreateManyWithoutPlayerInput {
        create: [NotifierCreateWithoutPlayerInput!]
        connect: [NotifierWhereUniqueInput!]
      }

      input NotifierCreateWithoutPlayerInput {
        seq: Int
        area: NotifierCreateareaInput
        date: String
        startTime: String
        endTime: String
      }

      type NotifierEdge {
        node: Notifier!
        cursor: String!
      }

      enum NotifierOrderByInput {
        seq_ASC
        seq_DESC
        date_ASC
        date_DESC
        startTime_ASC
        startTime_DESC
        endTime_ASC
        endTime_DESC
      }

      type NotifierPreviousValues {
        seq: Int!
        area: [Area!]!
        date: String
        startTime: String
        endTime: String
      }

      input NotifierScalarWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        date: String
        date_not: String
        date_in: [String!]
        date_not_in: [String!]
        date_lt: String
        date_lte: String
        date_gt: String
        date_gte: String
        date_contains: String
        date_not_contains: String
        date_starts_with: String
        date_not_starts_with: String
        date_ends_with: String
        date_not_ends_with: String
        startTime: String
        startTime_not: String
        startTime_in: [String!]
        startTime_not_in: [String!]
        startTime_lt: String
        startTime_lte: String
        startTime_gt: String
        startTime_gte: String
        startTime_contains: String
        startTime_not_contains: String
        startTime_starts_with: String
        startTime_not_starts_with: String
        startTime_ends_with: String
        startTime_not_ends_with: String
        endTime: String
        endTime_not: String
        endTime_in: [String!]
        endTime_not_in: [String!]
        endTime_lt: String
        endTime_lte: String
        endTime_gt: String
        endTime_gte: String
        endTime_contains: String
        endTime_not_contains: String
        endTime_starts_with: String
        endTime_not_starts_with: String
        endTime_ends_with: String
        endTime_not_ends_with: String
        AND: [NotifierScalarWhereInput!]
        OR: [NotifierScalarWhereInput!]
        NOT: [NotifierScalarWhereInput!]
      }

      type NotifierSubscriptionPayload {
        mutation: MutationType!
        node: Notifier
        updatedFields: [String!]
        previousValues: NotifierPreviousValues
      }

      input NotifierSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: NotifierWhereInput
        AND: [NotifierSubscriptionWhereInput!]
        OR: [NotifierSubscriptionWhereInput!]
        NOT: [NotifierSubscriptionWhereInput!]
      }

      input NotifierUpdateareaInput {
        set: [Area!]
      }

      input NotifierUpdateInput {
        player: PlayerUpdateOneRequiredWithoutNotiListInput
        area: NotifierUpdateareaInput
        date: String
        startTime: String
        endTime: String
      }

      input NotifierUpdateManyDataInput {
        area: NotifierUpdateareaInput
        date: String
        startTime: String
        endTime: String
      }

      input NotifierUpdateManyMutationInput {
        area: NotifierUpdateareaInput
        date: String
        startTime: String
        endTime: String
      }

      input NotifierUpdateManyWithoutPlayerInput {
        create: [NotifierCreateWithoutPlayerInput!]
        delete: [NotifierWhereUniqueInput!]
        connect: [NotifierWhereUniqueInput!]
        set: [NotifierWhereUniqueInput!]
        disconnect: [NotifierWhereUniqueInput!]
        update: [NotifierUpdateWithWhereUniqueWithoutPlayerInput!]
        upsert: [NotifierUpsertWithWhereUniqueWithoutPlayerInput!]
        deleteMany: [NotifierScalarWhereInput!]
        updateMany: [NotifierUpdateManyWithWhereNestedInput!]
      }

      input NotifierUpdateManyWithWhereNestedInput {
        where: NotifierScalarWhereInput!
        data: NotifierUpdateManyDataInput!
      }

      input NotifierUpdateWithoutPlayerDataInput {
        area: NotifierUpdateareaInput
        date: String
        startTime: String
        endTime: String
      }

      input NotifierUpdateWithWhereUniqueWithoutPlayerInput {
        where: NotifierWhereUniqueInput!
        data: NotifierUpdateWithoutPlayerDataInput!
      }

      input NotifierUpsertWithWhereUniqueWithoutPlayerInput {
        where: NotifierWhereUniqueInput!
        update: NotifierUpdateWithoutPlayerDataInput!
        create: NotifierCreateWithoutPlayerInput!
      }

      input NotifierWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        player: PlayerWhereInput
        date: String
        date_not: String
        date_in: [String!]
        date_not_in: [String!]
        date_lt: String
        date_lte: String
        date_gt: String
        date_gte: String
        date_contains: String
        date_not_contains: String
        date_starts_with: String
        date_not_starts_with: String
        date_ends_with: String
        date_not_ends_with: String
        startTime: String
        startTime_not: String
        startTime_in: [String!]
        startTime_not_in: [String!]
        startTime_lt: String
        startTime_lte: String
        startTime_gt: String
        startTime_gte: String
        startTime_contains: String
        startTime_not_contains: String
        startTime_starts_with: String
        startTime_not_starts_with: String
        startTime_ends_with: String
        startTime_not_ends_with: String
        endTime: String
        endTime_not: String
        endTime_in: [String!]
        endTime_not_in: [String!]
        endTime_lt: String
        endTime_lte: String
        endTime_gt: String
        endTime_gte: String
        endTime_contains: String
        endTime_not_contains: String
        endTime_starts_with: String
        endTime_not_starts_with: String
        endTime_ends_with: String
        endTime_not_ends_with: String
        AND: [NotifierWhereInput!]
        OR: [NotifierWhereInput!]
        NOT: [NotifierWhereInput!]
      }

      input NotifierWhereUniqueInput {
        seq: Int
      }

      type PageInfo {
        hasNextPage: Boolean!
        hasPreviousPage: Boolean!
        startCursor: String
        endCursor: String
      }

      type Player {
        seq: Int!
        playerId: String!
        team: Team
        name: String
        phone: String
        email: String
        notiList(
          where: NotifierWhereInput
          orderBy: NotifierOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Notifier!]
      }

      type PlayerConnection {
        pageInfo: PageInfo!
        edges: [PlayerEdge]!
        aggregate: AggregatePlayer!
      }

      input PlayerCreateInput {
        seq: Int
        playerId: String!
        team: TeamCreateOneWithoutMembersInput
        name: String
        phone: String
        email: String
        notiList: NotifierCreateManyWithoutPlayerInput
      }

      input PlayerCreateManyWithoutTeamInput {
        create: [PlayerCreateWithoutTeamInput!]
        connect: [PlayerWhereUniqueInput!]
      }

      input PlayerCreateOneWithoutNotiListInput {
        create: PlayerCreateWithoutNotiListInput
        connect: PlayerWhereUniqueInput
      }

      input PlayerCreateWithoutNotiListInput {
        seq: Int
        playerId: String!
        team: TeamCreateOneWithoutMembersInput
        name: String
        phone: String
        email: String
      }

      input PlayerCreateWithoutTeamInput {
        seq: Int
        playerId: String!
        name: String
        phone: String
        email: String
        notiList: NotifierCreateManyWithoutPlayerInput
      }

      type PlayerEdge {
        node: Player!
        cursor: String!
      }

      enum PlayerOrderByInput {
        seq_ASC
        seq_DESC
        playerId_ASC
        playerId_DESC
        name_ASC
        name_DESC
        phone_ASC
        phone_DESC
        email_ASC
        email_DESC
      }

      type PlayerPreviousValues {
        seq: Int!
        playerId: String!
        name: String
        phone: String
        email: String
      }

      input PlayerScalarWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        playerId: String
        playerId_not: String
        playerId_in: [String!]
        playerId_not_in: [String!]
        playerId_lt: String
        playerId_lte: String
        playerId_gt: String
        playerId_gte: String
        playerId_contains: String
        playerId_not_contains: String
        playerId_starts_with: String
        playerId_not_starts_with: String
        playerId_ends_with: String
        playerId_not_ends_with: String
        name: String
        name_not: String
        name_in: [String!]
        name_not_in: [String!]
        name_lt: String
        name_lte: String
        name_gt: String
        name_gte: String
        name_contains: String
        name_not_contains: String
        name_starts_with: String
        name_not_starts_with: String
        name_ends_with: String
        name_not_ends_with: String
        phone: String
        phone_not: String
        phone_in: [String!]
        phone_not_in: [String!]
        phone_lt: String
        phone_lte: String
        phone_gt: String
        phone_gte: String
        phone_contains: String
        phone_not_contains: String
        phone_starts_with: String
        phone_not_starts_with: String
        phone_ends_with: String
        phone_not_ends_with: String
        email: String
        email_not: String
        email_in: [String!]
        email_not_in: [String!]
        email_lt: String
        email_lte: String
        email_gt: String
        email_gte: String
        email_contains: String
        email_not_contains: String
        email_starts_with: String
        email_not_starts_with: String
        email_ends_with: String
        email_not_ends_with: String
        AND: [PlayerScalarWhereInput!]
        OR: [PlayerScalarWhereInput!]
        NOT: [PlayerScalarWhereInput!]
      }

      type PlayerSubscriptionPayload {
        mutation: MutationType!
        node: Player
        updatedFields: [String!]
        previousValues: PlayerPreviousValues
      }

      input PlayerSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: PlayerWhereInput
        AND: [PlayerSubscriptionWhereInput!]
        OR: [PlayerSubscriptionWhereInput!]
        NOT: [PlayerSubscriptionWhereInput!]
      }

      input PlayerUpdateInput {
        playerId: String
        team: TeamUpdateOneWithoutMembersInput
        name: String
        phone: String
        email: String
        notiList: NotifierUpdateManyWithoutPlayerInput
      }

      input PlayerUpdateManyDataInput {
        playerId: String
        name: String
        phone: String
        email: String
      }

      input PlayerUpdateManyMutationInput {
        playerId: String
        name: String
        phone: String
        email: String
      }

      input PlayerUpdateManyWithoutTeamInput {
        create: [PlayerCreateWithoutTeamInput!]
        delete: [PlayerWhereUniqueInput!]
        connect: [PlayerWhereUniqueInput!]
        set: [PlayerWhereUniqueInput!]
        disconnect: [PlayerWhereUniqueInput!]
        update: [PlayerUpdateWithWhereUniqueWithoutTeamInput!]
        upsert: [PlayerUpsertWithWhereUniqueWithoutTeamInput!]
        deleteMany: [PlayerScalarWhereInput!]
        updateMany: [PlayerUpdateManyWithWhereNestedInput!]
      }

      input PlayerUpdateManyWithWhereNestedInput {
        where: PlayerScalarWhereInput!
        data: PlayerUpdateManyDataInput!
      }

      input PlayerUpdateOneRequiredWithoutNotiListInput {
        create: PlayerCreateWithoutNotiListInput
        update: PlayerUpdateWithoutNotiListDataInput
        upsert: PlayerUpsertWithoutNotiListInput
        connect: PlayerWhereUniqueInput
      }

      input PlayerUpdateWithoutNotiListDataInput {
        playerId: String
        team: TeamUpdateOneWithoutMembersInput
        name: String
        phone: String
        email: String
      }

      input PlayerUpdateWithoutTeamDataInput {
        playerId: String
        name: String
        phone: String
        email: String
        notiList: NotifierUpdateManyWithoutPlayerInput
      }

      input PlayerUpdateWithWhereUniqueWithoutTeamInput {
        where: PlayerWhereUniqueInput!
        data: PlayerUpdateWithoutTeamDataInput!
      }

      input PlayerUpsertWithoutNotiListInput {
        update: PlayerUpdateWithoutNotiListDataInput!
        create: PlayerCreateWithoutNotiListInput!
      }

      input PlayerUpsertWithWhereUniqueWithoutTeamInput {
        where: PlayerWhereUniqueInput!
        update: PlayerUpdateWithoutTeamDataInput!
        create: PlayerCreateWithoutTeamInput!
      }

      input PlayerWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        playerId: String
        playerId_not: String
        playerId_in: [String!]
        playerId_not_in: [String!]
        playerId_lt: String
        playerId_lte: String
        playerId_gt: String
        playerId_gte: String
        playerId_contains: String
        playerId_not_contains: String
        playerId_starts_with: String
        playerId_not_starts_with: String
        playerId_ends_with: String
        playerId_not_ends_with: String
        team: TeamWhereInput
        name: String
        name_not: String
        name_in: [String!]
        name_not_in: [String!]
        name_lt: String
        name_lte: String
        name_gt: String
        name_gte: String
        name_contains: String
        name_not_contains: String
        name_starts_with: String
        name_not_starts_with: String
        name_ends_with: String
        name_not_ends_with: String
        phone: String
        phone_not: String
        phone_in: [String!]
        phone_not_in: [String!]
        phone_lt: String
        phone_lte: String
        phone_gt: String
        phone_gte: String
        phone_contains: String
        phone_not_contains: String
        phone_starts_with: String
        phone_not_starts_with: String
        phone_ends_with: String
        phone_not_ends_with: String
        email: String
        email_not: String
        email_in: [String!]
        email_not_in: [String!]
        email_lt: String
        email_lte: String
        email_gt: String
        email_gte: String
        email_contains: String
        email_not_contains: String
        email_starts_with: String
        email_not_starts_with: String
        email_ends_with: String
        email_not_ends_with: String
        notiList_every: NotifierWhereInput
        notiList_some: NotifierWhereInput
        notiList_none: NotifierWhereInput
        AND: [PlayerWhereInput!]
        OR: [PlayerWhereInput!]
        NOT: [PlayerWhereInput!]
      }

      input PlayerWhereUniqueInput {
        seq: Int
        playerId: String
        email: String
      }

      type Query {
        apply(where: ApplyWhereUniqueInput!): Apply
        applies(
          where: ApplyWhereInput
          orderBy: ApplyOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Apply]!
        appliesConnection(
          where: ApplyWhereInput
          orderBy: ApplyOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): ApplyConnection!
        match(where: MatchWhereUniqueInput!): Match
        matches(
          where: MatchWhereInput
          orderBy: MatchOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Match]!
        matchesConnection(
          where: MatchWhereInput
          orderBy: MatchOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): MatchConnection!
        notifier(where: NotifierWhereUniqueInput!): Notifier
        notifiers(
          where: NotifierWhereInput
          orderBy: NotifierOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Notifier]!
        notifiersConnection(
          where: NotifierWhereInput
          orderBy: NotifierOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): NotifierConnection!
        player(where: PlayerWhereUniqueInput!): Player
        players(
          where: PlayerWhereInput
          orderBy: PlayerOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Player]!
        playersConnection(
          where: PlayerWhereInput
          orderBy: PlayerOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): PlayerConnection!
        stadium(where: StadiumWhereUniqueInput!): Stadium
        stadiums(
          where: StadiumWhereInput
          orderBy: StadiumOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Stadium]!
        stadiumsConnection(
          where: StadiumWhereInput
          orderBy: StadiumOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): StadiumConnection!
        team(where: TeamWhereUniqueInput!): Team
        teams(
          where: TeamWhereInput
          orderBy: TeamOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Team]!
        teamsConnection(
          where: TeamWhereInput
          orderBy: TeamOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): TeamConnection!
        node(id: ID!): Node
      }

      enum Result {
        HOST
        GUEST
        DRAW
      }

      type Stadium {
        seq: Int!
        name: String
        address: String
      }

      type StadiumConnection {
        pageInfo: PageInfo!
        edges: [StadiumEdge]!
        aggregate: AggregateStadium!
      }

      input StadiumCreateInput {
        seq: Int
        name: String
        address: String
      }

      type StadiumEdge {
        node: Stadium!
        cursor: String!
      }

      enum StadiumOrderByInput {
        seq_ASC
        seq_DESC
        name_ASC
        name_DESC
        address_ASC
        address_DESC
      }

      type StadiumPreviousValues {
        seq: Int!
        name: String
        address: String
      }

      type StadiumSubscriptionPayload {
        mutation: MutationType!
        node: Stadium
        updatedFields: [String!]
        previousValues: StadiumPreviousValues
      }

      input StadiumSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: StadiumWhereInput
        AND: [StadiumSubscriptionWhereInput!]
        OR: [StadiumSubscriptionWhereInput!]
        NOT: [StadiumSubscriptionWhereInput!]
      }

      input StadiumUpdateInput {
        name: String
        address: String
      }

      input StadiumUpdateManyMutationInput {
        name: String
        address: String
      }

      input StadiumWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        name: String
        name_not: String
        name_in: [String!]
        name_not_in: [String!]
        name_lt: String
        name_lte: String
        name_gt: String
        name_gte: String
        name_contains: String
        name_not_contains: String
        name_starts_with: String
        name_not_starts_with: String
        name_ends_with: String
        name_not_ends_with: String
        address: String
        address_not: String
        address_in: [String!]
        address_not_in: [String!]
        address_lt: String
        address_lte: String
        address_gt: String
        address_gte: String
        address_contains: String
        address_not_contains: String
        address_starts_with: String
        address_not_starts_with: String
        address_ends_with: String
        address_not_ends_with: String
        AND: [StadiumWhereInput!]
        OR: [StadiumWhereInput!]
        NOT: [StadiumWhereInput!]
      }

      input StadiumWhereUniqueInput {
        seq: Int
      }

      type Subscription {
        apply(where: ApplySubscriptionWhereInput): ApplySubscriptionPayload
        match(where: MatchSubscriptionWhereInput): MatchSubscriptionPayload
        notifier(
          where: NotifierSubscriptionWhereInput
        ): NotifierSubscriptionPayload
        player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
        stadium(
          where: StadiumSubscriptionWhereInput
        ): StadiumSubscriptionPayload
        team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
      }

      type Team {
        seq: Int!
        name: String!
        logo: String
        homeArea: Area
        introduction: String
        win: Int!
        draw: Int!
        lose: Int!
        rating: Int!
        members(
          where: PlayerWhereInput
          orderBy: PlayerOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Player!]
        uploadMatchList(
          where: MatchWhereInput
          orderBy: MatchOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Match!]
        matchingDoneList(
          where: MatchWhereInput
          orderBy: MatchOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Match!]
        onApplyingList(
          where: ApplyWhereInput
          orderBy: ApplyOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Apply!]
      }

      type TeamConnection {
        pageInfo: PageInfo!
        edges: [TeamEdge]!
        aggregate: AggregateTeam!
      }

      input TeamCreateInput {
        seq: Int
        name: String!
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        members: PlayerCreateManyWithoutTeamInput
        uploadMatchList: MatchCreateManyWithoutHostInput
        matchingDoneList: MatchCreateManyWithoutGuestInput
        onApplyingList: ApplyCreateManyWithoutTeamInput
      }

      input TeamCreateOneWithoutMatchingDoneListInput {
        create: TeamCreateWithoutMatchingDoneListInput
        connect: TeamWhereUniqueInput
      }

      input TeamCreateOneWithoutMembersInput {
        create: TeamCreateWithoutMembersInput
        connect: TeamWhereUniqueInput
      }

      input TeamCreateOneWithoutOnApplyingListInput {
        create: TeamCreateWithoutOnApplyingListInput
        connect: TeamWhereUniqueInput
      }

      input TeamCreateOneWithoutUploadMatchListInput {
        create: TeamCreateWithoutUploadMatchListInput
        connect: TeamWhereUniqueInput
      }

      input TeamCreateWithoutMatchingDoneListInput {
        seq: Int
        name: String!
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        members: PlayerCreateManyWithoutTeamInput
        uploadMatchList: MatchCreateManyWithoutHostInput
        onApplyingList: ApplyCreateManyWithoutTeamInput
      }

      input TeamCreateWithoutMembersInput {
        seq: Int
        name: String!
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        uploadMatchList: MatchCreateManyWithoutHostInput
        matchingDoneList: MatchCreateManyWithoutGuestInput
        onApplyingList: ApplyCreateManyWithoutTeamInput
      }

      input TeamCreateWithoutOnApplyingListInput {
        seq: Int
        name: String!
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        members: PlayerCreateManyWithoutTeamInput
        uploadMatchList: MatchCreateManyWithoutHostInput
        matchingDoneList: MatchCreateManyWithoutGuestInput
      }

      input TeamCreateWithoutUploadMatchListInput {
        seq: Int
        name: String!
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        members: PlayerCreateManyWithoutTeamInput
        matchingDoneList: MatchCreateManyWithoutGuestInput
        onApplyingList: ApplyCreateManyWithoutTeamInput
      }

      type TeamEdge {
        node: Team!
        cursor: String!
      }

      enum TeamOrderByInput {
        seq_ASC
        seq_DESC
        name_ASC
        name_DESC
        logo_ASC
        logo_DESC
        homeArea_ASC
        homeArea_DESC
        introduction_ASC
        introduction_DESC
        win_ASC
        win_DESC
        draw_ASC
        draw_DESC
        lose_ASC
        lose_DESC
        rating_ASC
        rating_DESC
      }

      type TeamPreviousValues {
        seq: Int!
        name: String!
        logo: String
        homeArea: Area
        introduction: String
        win: Int!
        draw: Int!
        lose: Int!
        rating: Int!
      }

      type TeamSubscriptionPayload {
        mutation: MutationType!
        node: Team
        updatedFields: [String!]
        previousValues: TeamPreviousValues
      }

      input TeamSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: TeamWhereInput
        AND: [TeamSubscriptionWhereInput!]
        OR: [TeamSubscriptionWhereInput!]
        NOT: [TeamSubscriptionWhereInput!]
      }

      input TeamUpdateInput {
        name: String
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        members: PlayerUpdateManyWithoutTeamInput
        uploadMatchList: MatchUpdateManyWithoutHostInput
        matchingDoneList: MatchUpdateManyWithoutGuestInput
        onApplyingList: ApplyUpdateManyWithoutTeamInput
      }

      input TeamUpdateManyMutationInput {
        name: String
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
      }

      input TeamUpdateOneWithoutMatchingDoneListInput {
        create: TeamCreateWithoutMatchingDoneListInput
        update: TeamUpdateWithoutMatchingDoneListDataInput
        upsert: TeamUpsertWithoutMatchingDoneListInput
        delete: Boolean
        disconnect: Boolean
        connect: TeamWhereUniqueInput
      }

      input TeamUpdateOneWithoutMembersInput {
        create: TeamCreateWithoutMembersInput
        update: TeamUpdateWithoutMembersDataInput
        upsert: TeamUpsertWithoutMembersInput
        delete: Boolean
        disconnect: Boolean
        connect: TeamWhereUniqueInput
      }

      input TeamUpdateOneWithoutOnApplyingListInput {
        create: TeamCreateWithoutOnApplyingListInput
        update: TeamUpdateWithoutOnApplyingListDataInput
        upsert: TeamUpsertWithoutOnApplyingListInput
        delete: Boolean
        disconnect: Boolean
        connect: TeamWhereUniqueInput
      }

      input TeamUpdateOneWithoutUploadMatchListInput {
        create: TeamCreateWithoutUploadMatchListInput
        update: TeamUpdateWithoutUploadMatchListDataInput
        upsert: TeamUpsertWithoutUploadMatchListInput
        delete: Boolean
        disconnect: Boolean
        connect: TeamWhereUniqueInput
      }

      input TeamUpdateWithoutMatchingDoneListDataInput {
        name: String
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        members: PlayerUpdateManyWithoutTeamInput
        uploadMatchList: MatchUpdateManyWithoutHostInput
        onApplyingList: ApplyUpdateManyWithoutTeamInput
      }

      input TeamUpdateWithoutMembersDataInput {
        name: String
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        uploadMatchList: MatchUpdateManyWithoutHostInput
        matchingDoneList: MatchUpdateManyWithoutGuestInput
        onApplyingList: ApplyUpdateManyWithoutTeamInput
      }

      input TeamUpdateWithoutOnApplyingListDataInput {
        name: String
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        members: PlayerUpdateManyWithoutTeamInput
        uploadMatchList: MatchUpdateManyWithoutHostInput
        matchingDoneList: MatchUpdateManyWithoutGuestInput
      }

      input TeamUpdateWithoutUploadMatchListDataInput {
        name: String
        logo: String
        homeArea: Area
        introduction: String
        win: Int
        draw: Int
        lose: Int
        rating: Int
        members: PlayerUpdateManyWithoutTeamInput
        matchingDoneList: MatchUpdateManyWithoutGuestInput
        onApplyingList: ApplyUpdateManyWithoutTeamInput
      }

      input TeamUpsertWithoutMatchingDoneListInput {
        update: TeamUpdateWithoutMatchingDoneListDataInput!
        create: TeamCreateWithoutMatchingDoneListInput!
      }

      input TeamUpsertWithoutMembersInput {
        update: TeamUpdateWithoutMembersDataInput!
        create: TeamCreateWithoutMembersInput!
      }

      input TeamUpsertWithoutOnApplyingListInput {
        update: TeamUpdateWithoutOnApplyingListDataInput!
        create: TeamCreateWithoutOnApplyingListInput!
      }

      input TeamUpsertWithoutUploadMatchListInput {
        update: TeamUpdateWithoutUploadMatchListDataInput!
        create: TeamCreateWithoutUploadMatchListInput!
      }

      input TeamWhereInput {
        seq: Int
        seq_not: Int
        seq_in: [Int!]
        seq_not_in: [Int!]
        seq_lt: Int
        seq_lte: Int
        seq_gt: Int
        seq_gte: Int
        name: String
        name_not: String
        name_in: [String!]
        name_not_in: [String!]
        name_lt: String
        name_lte: String
        name_gt: String
        name_gte: String
        name_contains: String
        name_not_contains: String
        name_starts_with: String
        name_not_starts_with: String
        name_ends_with: String
        name_not_ends_with: String
        logo: String
        logo_not: String
        logo_in: [String!]
        logo_not_in: [String!]
        logo_lt: String
        logo_lte: String
        logo_gt: String
        logo_gte: String
        logo_contains: String
        logo_not_contains: String
        logo_starts_with: String
        logo_not_starts_with: String
        logo_ends_with: String
        logo_not_ends_with: String
        homeArea: Area
        homeArea_not: Area
        homeArea_in: [Area!]
        homeArea_not_in: [Area!]
        introduction: String
        introduction_not: String
        introduction_in: [String!]
        introduction_not_in: [String!]
        introduction_lt: String
        introduction_lte: String
        introduction_gt: String
        introduction_gte: String
        introduction_contains: String
        introduction_not_contains: String
        introduction_starts_with: String
        introduction_not_starts_with: String
        introduction_ends_with: String
        introduction_not_ends_with: String
        win: Int
        win_not: Int
        win_in: [Int!]
        win_not_in: [Int!]
        win_lt: Int
        win_lte: Int
        win_gt: Int
        win_gte: Int
        draw: Int
        draw_not: Int
        draw_in: [Int!]
        draw_not_in: [Int!]
        draw_lt: Int
        draw_lte: Int
        draw_gt: Int
        draw_gte: Int
        lose: Int
        lose_not: Int
        lose_in: [Int!]
        lose_not_in: [Int!]
        lose_lt: Int
        lose_lte: Int
        lose_gt: Int
        lose_gte: Int
        rating: Int
        rating_not: Int
        rating_in: [Int!]
        rating_not_in: [Int!]
        rating_lt: Int
        rating_lte: Int
        rating_gt: Int
        rating_gte: Int
        members_every: PlayerWhereInput
        members_some: PlayerWhereInput
        members_none: PlayerWhereInput
        uploadMatchList_every: MatchWhereInput
        uploadMatchList_some: MatchWhereInput
        uploadMatchList_none: MatchWhereInput
        matchingDoneList_every: MatchWhereInput
        matchingDoneList_some: MatchWhereInput
        matchingDoneList_none: MatchWhereInput
        onApplyingList_every: ApplyWhereInput
        onApplyingList_some: ApplyWhereInput
        onApplyingList_none: ApplyWhereInput
        AND: [TeamWhereInput!]
        OR: [TeamWhereInput!]
        NOT: [TeamWhereInput!]
      }

      input TeamWhereUniqueInput {
        seq: Int
      }
    `,
};
